#===============================================================================
# Chrono project configuration file
#
# This file is automatically generated when Chrono is configured and contains
# information on how the project was configured.  It can be used by third party
# projects in their own CMakeLists files to find the Chrono package and obtain
# information on how to link to the Chrono libraries.
#
# In the call to find_package(), the following Chrono components can be
# requested (case insensitive): 
#   Cascade, CSharp, FMI, FSI, GPU, Irrlicht, Matlab, Modal, Multicore,
#   OpenGL, PardisoMKL, Parsers, Postprocess, Sensor, Synchrono,
#   Vehicle, VehicleCosim, VSG.
# A component can be requested either as required or optional
# (see the CMake documentation for find_package).
#
# Variables set by this script:
# Chrono_FOUND
#       set to true if Chrono and all required components were found
# CHRONO_TARGETS
#       list of exported Chrono targets
# CHRONO_STATIC
#       set to ON if Chrono static libraries were built, OFF if shared libraries
# CHRONO_MSVC_RUNTIME_LIBRARY
#       MSVC run-time library used in building Chrono
# CHRONO_DLL_NAMES
#       (Windows) list of Chrono DLLs (without path)
# CHRONO_CSHARP_SOURCES
#       list of all SWIG-generated C# scripts corresponding to the requested components
#       (currently, only the core, postprocess, Irrlicht, and Vehicle Chrono are wrapped)
# CHRONO_DATA_DIR
#       path to the Chrono data directory
# CHRONO_VEHICLE_DATA_DIR
#       path to the Chrono::Vehicle data directory
# CHRONO_FSI_DATA_DIR
#       path to the Chrono::FSI data directory
# SYNCHRONO_DATA_DIR
#       path to the Chrono::Synchrono data directory
#
# In addition, for each requested component <COMPONENT>, the following variable
# is set to true (ON) or false (OFF):
# CHRONO_<COMPONENT_UPPER>_FOUND
# where <COMPONENT_UPPER> is the component name in upper case.
#
# Certain Chrono modules can be configured with optional support. The following
# variables (meaningful only if the corresponding Chrono module is requested)
# can be used to check if these options are available:
# * Chrono::Parsers module
#     CHRONO_PARSERS_URDF
#       set to true if URDF support is available.
#     CHRONO_PARSERS_PYTHON
#       set to true if Python support is available.
# * Chrono::Vehicle module
#     CHRONO_VEHICLE_OPENCRG
#       set to true if OpenCRG support is vailable.
#     CHRONO_VEHICLE_IRRKLANG
#       set to true if Irrklang support is available.
# * Chrono::Synchrono module
#     CHRONO_SYNCHRONO_FASTDDS
#       set to true if FastDDS support is available.
#       The user must still invoke fast_package(fastrtps)
#===============================================================================

@PACKAGE_INIT@

# --------------------------------------------------------------------------

# Create a variable with the current location of this package.
# Note: using CMAKE_CURRENT_LIST_DIR or PACKAGE_PREFIX_DIR (autogenerated by PACKAGE_INIT above)
#       will not work as these point to the source folder
set(CHRONO_PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/../")

# --------------------------------------------------------------------------

if (CHRONO_CONFIG_INCLUDED)
  return()
endif()
set(CHRONO_CONFIG_INCLUDED TRUE)


list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})

include("${CMAKE_CURRENT_LIST_DIR}/ChronoTargets.cmake")

set(CHRONO_INSTALL_TREE @CH_INSTALL_TREE@)

include(CMakeFindDependencyMacro)

# Handle MSVC Runtime Library
set(CHRONO_MSVC_RUNTIME_LIBRARY @CH_MSVC_RUNTIME_LIBRARY@)

set(CHRONO_STATIC @CH_STATIC@)

#-------------------------------------------------------------------------------
# Local variables specifying Chrono support
#-------------------------------------------------------------------------------

set(CHRONO_SSE_AVAILABLE @SSE_FOUND@)
set(CHRONO_AVX_AVAILABLE @AVX_FOUND@)
set(CHRONO_OPENMP_CXX_AVAILABLE @OpenMP_CXX_FOUND@)
set(CHRONO_THRUST_AVAILABLE @Thrust_FOUND@)
set(CHRONO_MPI_CXX_AVAILABLE @MPI_CXX_FOUND@)

set(CHRONO_CUDA_ARCHITECTURES "@CHRONO_CUDA_ARCHITECTURES@")

#-------------------------------------------------------------------------------
# Local variables specifying which Chrono modules are available
#-------------------------------------------------------------------------------

set(Chrono_CASCADE_AVAILABLE        @CH_ENABLE_MODULE_CASCADE@)
set(Chrono_IRRLICHT_AVAILABLE       @CH_ENABLE_MODULE_IRRLICHT@)
set(Chrono_MATLAB_AVAILABLE         @CH_ENABLE_MODULE_MATLAB@)
set(Chrono_PARDISOMKL_AVAILABLE     @CH_ENABLE_MODULE_PARDISO_MKL@)
set(Chrono_MUMPS_AVAILABLE          @CH_ENABLE_MODULE_MUMPS@)
set(Chrono_MULTICORE_AVAILABLE      @CH_ENABLE_MODULE_MULTICORE@)
set(Chrono_OPENGL_AVAILABLE         @CH_ENABLE_MODULE_OPENGL@)
set(Chrono_POSTPROCESS_AVAILABLE    @CH_ENABLE_MODULE_POSTPROCESS@)
set(Chrono_PARSERS_AVAILABLE        @CH_ENABLE_MODULE_PARSERS@)
set(Chrono_VEHICLE_AVAILABLE        @CH_ENABLE_MODULE_VEHICLE@)
set(Chrono_FSI_AVAILABLE            @CH_ENABLE_MODULE_FSI@)
set(Chrono_GPU_AVAILABLE            @CH_ENABLE_MODULE_GPU@)
set(Chrono_SENSOR_AVAILABLE         @CH_ENABLE_MODULE_SENSOR@)
set(Chrono_SYNCHRONO_AVAILABLE      @CH_ENABLE_MODULE_SYNCHRONO@)
set(Chrono_MODAL_AVAILABLE          @CH_ENABLE_MODULE_MODAL@)
set(Chrono_VSG_AVAILABLE            @CH_ENABLE_MODULE_VSG@)
set(Chrono_CSHARP_AVAILABLE         @CH_ENABLE_MODULE_CSHARP@)
set(Chrono_FMI_AVAILABLE            @CH_ENABLE_MODULE_FMI@)
set(Chrono_ROS_AVAILABLE            @CH_ENABLE_MODULE_ROS@)

if(CHRONO_MPI_CXX_AVAILABLE)
   set(Chrono_VEHICLECOSIM_AVAILABLE TRUE)
else()
   set(Chrono_VEHICLECOSIM_AVAILABLE FALSE)
endif()

#-------------------------------------------------------------------------------
# Lists of Chrono module inter-dependencies
#-------------------------------------------------------------------------------

set(Chrono_CASCADE_DEPENDENCIES        "@DEPENDENCIES_CASCADE@")
set(Chrono_IRRLICHT_DEPENDENCIES       "@DEPENDENCIES_IRRLICHT@")
set(Chrono_MATLAB_DEPENDENCIES         "@DEPENDENCIES_MATLAB@")
set(Chrono_PARDISOMKL_DEPENDENCIES     "@DEPENDENCIES_PARDISO_MKL@")
set(Chrono_MUMPS_DEPENDENCIES          "@DEPENDENCIES_MUMPS@")
set(Chrono_MULTICORE_DEPENDENCIES      "@DEPENDENCIES_MULTICORE@")
set(Chrono_OPENGL_DEPENDENCIES         "@DEPENDENCIES_OPENGL@")
set(Chrono_POSTPROCESS_DEPENDENCIES    "@DEPENDENCIES_POSTPROCESS@")
set(Chrono_PARSERS_DEPENDENCIES        "@DEPENDENCIES_PARSERS@")
set(Chrono_VEHICLE_DEPENDENCIES        "@DEPENDENCIES_VEHICLE@")
set(Chrono_FSI_DEPENDENCIES            "@DEPENDENCIES_FSI@")
set(Chrono_GPU_DEPENDENCIES            "@DEPENDENCIES_GPU@")
set(Chrono_SENSOR_DEPENDENCIES         "@DEPENDENCIES_SENSOR@")
set(Chrono_SYNCHRONO_DEPENDENCIES      "@DEPENDENCIES_SYNCHRONO@")
set(Chrono_MODAL_DEPENDENCIES          "@DEPENDENCIES_MODAL@")
set(Chrono_VSG_DEPENDENCIES            "@DEPENDENCIES_VSG@")
set(Chrono_ROS_DEPENDENCIES            "@DEPENDENCIES_ROS@")
set(Chrono_VEHICLECOSIM_DEPENDENCIES   "@DEPENDENCIES_VEHICLECOSIM@")

#-------------------------------------------------------------------------------
# Build complete list of Chrono modules (requested and their dependencies)
#-------------------------------------------------------------------------------

# Recursively find all Chrono dependencies of the specified Chrono module
function(get_dependencies OUTPUT_LIST COMPONENT)
    # Mark the component as "visited"
    list(APPEND VISITED_TARGETS ${COMPONENT})

    # Load top-level component dependencies
    string(TOUPPER ${COMPONENT} COMPONENT_UPPER)
    set(TOP_DEPENDENCIES ${Chrono_${COMPONENT_UPPER}_DEPENDENCIES})

    # Initialize list of all inherited component dependencies
    set(ALL_DEPENDENCIES "")

    # Recurse starting at each top-level dependency
    foreach(DEP ${TOP_DEPENDENCIES})
       list(FIND VISITED_TARGETS ${DEP} VISITED)
       if (${VISITED} EQUAL -1)
          get_dependencies(DEP_DEPENDENCIES ${DEP})
          list(APPEND ALL_DEPENDENCIES ${DEP} ${DEP_DEPENDENCIES})
       endif()
    endforeach()

    # Make variables visible above (for recursive calls)
    set(VISITED_TARGETS ${VISITED_TARGETS} PARENT_SCOPE)
    set(${OUTPUT_LIST} ${ALL_DEPENDENCIES} PARENT_SCOPE)
endfunction()

# Build union of all Chrono dependencies starting from the requested components
set(Chrono_COMPONENTS "")
foreach(COMPONENT ${Chrono_FIND_COMPONENTS})
  string(TOUPPER ${COMPONENT} COMPONENT_UPPER)

  list(APPEND Chrono_COMPONENTS ${COMPONENT_UPPER})

  get_dependencies(DEPENDENCIES ${COMPONENT_UPPER})
  list(APPEND Chrono_COMPONENTS ${DEPENDENCIES})

  if(Chrono_FIND_REQUIRED_${COMPONENT})
    set(Chrono_${COMPONENT_UPPER}_REQUIRED TRUE)
  else()
    set(Chrono_${COMPONENT_UPPER}_REQUIRED FALSE)
  endif()

  if(NOT Chrono_FIND_QUIETLY)
    message(STATUS "Requested component: ${COMPONENT}")
    message(STATUS "  dependencies: ${DEPENDENCIES}")
    message(STATUS "  required?     ${Chrono_${COMPONENT_UPPER}_REQUIRED}")
  endif()
endforeach()

# Remove duplicates
list(REMOVE_DUPLICATES Chrono_COMPONENTS)
if(NOT Chrono_FIND_QUIETLY)
  message(STATUS "Inclusive list of Chrono components: ${Chrono_COMPONENTS}")
endif()

# Set all components in list as "REQUESTED"
foreach(COMPONENT_UPPER ${Chrono_COMPONENTS})
  set(Chrono_${COMPONENT_UPPER}_REQUESTED TRUE)
endforeach()

#-------------------------------------------------------------------------------
# Check if C++ language is enabled.
# If it is not, certain modules will be disabled:
# - Chrono::Multicore which requires OpenMP for C++
# - Chrono::Vehicle co-simulation which requires MPI for C++
# - Chrono::VSG which calls FindThreads
#-------------------------------------------------------------------------------

get_property(CURRENT_ENABLED_LANGUAGES GLOBAL PROPERTY ENABLED_LANGUAGES)
list(FIND CURRENT_ENABLED_LANGUAGES CXX LANG_INDEX)
if(LANG_INDEX EQUAL -1)
  message("WARNING: C++ language is not enabled. Features that require C++ (e.g., MPI, OpenMP, VSG) will be disabled")
  set(CHRONO_CXX_FOUND FALSE)
else()
  set(CHRONO_CXX_FOUND TRUE)
endif()


#-------------------------------------------------------------------------------
# Find Eigen3
#-------------------------------------------------------------------------------

set(EIGEN3_INCLUDE_DIR "@EIGEN3_INCLUDE_DIR@" CACHE PATH "Path to Eigen3 directory (should contain a subfolder named \"Eigen\"")
set(Eigen3_DIR "@Eigen3_DIR@" CACHE PATH "Path to Eigen3 config file (should contain the \"Eigen3Config.cmake\" file")

find_package(Eigen3 3.3 QUIET)

if(EIGEN3_FOUND)
  if(NOT Chrono_FIND_QUIETLY)
    message(STATUS "Eigen3 found")
  endif()
  mark_as_advanced(FORCE EIGEN3_INCLUDE_DIR)
  mark_as_advanced(FORCE Eigen3_DIR)
else()
  if(NOT Chrono_FIND_QUIETLY)
    message("ERROR:  Eigen3 cannot be found. Set either EIGEN3_INCLUDE_DIR or the envvar Eigen3_ROOT to the location of Eigen library or provide location of Eigen3Config.cmake through Eigen3_DIR.")
  endif()
  return()
endif()

#-------------------------------------------------------------------------------
# Check OpenMP if Chrono was built with OpenMP support
#-------------------------------------------------------------------------------

if(CHRONO_OPENMP_CXX_AVAILABLE AND @CH_ENABLE_OPENMP@ AND CHRONO_CXX_FOUND)
  find_package(OpenMP COMPONENTS CXX)
  if(OpenMP_CXX_FOUND)
    if(NOT Chrono_FIND_QUIETLY)
      message(STATUS "OpenMP found")
    endif()
    set(CHRONO_OPENMP_CXX_FOUND TRUE)
  else()
    if(NOT Chrono_FIND_QUIETLY)
      message("WARNING: OpenMP not found")
    endif()
    set(CHRONO_OPENMP_CXX_FOUND FALSE)
  endif()
endif()

#-------------------------------------------------------------------------------
# Enable CUDA if necessary
#-------------------------------------------------------------------------------

if(Chrono_GPU_REQUESTED OR Chrono_FSI_REQUESTED OR Chrono_SENSOR_REQUESTED)
  set(CMAKE_CUDA_COMPILER "@CMAKE_CUDA_COMPILER@" CACHE PATH "CUDA compiler")
  set(CUDAToolkit_DIR "@CUDAToolkit_LIBRARY_ROOT@" CACHE PATH "CUDAToolkit library location (should contain 'version.json')")

  set(CHRONO_CUDA_FOUND TRUE)

  include(CheckLanguage)
  check_language(CUDA)
  
  find_package(CUDAToolkit QUIET)

  if(CHRONO_CUDA_ARCHITECTURES STREQUAL "")
    if(CMAKE_VERSION VERSION_GREATER_EQUAL "3.23")
      set(CHRONO_CUDA_ARCHITECTURES "all-major" CACHE STRING "Chrono CUDA architectures" FORCE)
    endif()
  endif()

  if(CHRONO_CUDA_ARCHITECTURES STREQUAL "")
    set(CHRONO_CUDA_FOUND FALSE)
    message("WARNING: CUDA architectures not found. Set CHRONO_CUDA_ARCHITECTURES")
  else()
    set(CMAKE_CUDA_ARCHITECTURES ${CHRONO_CUDA_ARCHITECTURES} CACHE STRING "CUDA architectures" FORCE)
  endif()

  if(CHRONO_CUDA_FOUND AND CMAKE_CUDA_COMPILER AND CUDAToolkit_FOUND)
    enable_language(CUDA)
    if(NOT Chrono_FIND_QUIETLY)
      message(STATUS "CUDA found")
    endif()
    mark_as_advanced(FORCE CUDAToolkit_DIR)
  else()
    set(CHRONO_CUDA_FOUND FALSE)
    if (NOT Chrono_FIND_QUIETLY)
      message("WARNING: CUDA not found")
    endif()
    mark_as_advanced(CLEAR CUDAToolkit_DIR)
  endif()
endif()

#-------------------------------------------------------------------------------
# Check Thrust if Chrono was built with Thrust support
#-------------------------------------------------------------------------------

if(CHRONO_THRUST_AVAILABLE)
  set(Thrust_ROOT "@THRUST_INCLUDE_DIR@" CACHE PATH "Thrust library location (should contain 'thrust/version.h')")
  find_package(Thrust QUIET)
  
  if(Thrust_FOUND)
    if(NOT Chrono_FIND_QUIETLY)
      message(STATUS "Thrust found")
    endif()
    mark_as_advanced(FORCE Thrust_ROOT)
    set(CHRONO_THRUST_FOUND TRUE)
  else()
    if(NOT Chrono_FIND_QUIETLY) 
      message("WARNING: Thrust not found")
    endif()
    mark_as_advanced(CLEAR Thrust_ROOT)
    set(CHRONO_THRUST_FOUND FALSE)
  endif()
endif()

#-------------------------------------------------------------------------------
# Check MPI if Chrono was built with MPI support
#-------------------------------------------------------------------------------

if(CHRONO_MPI_CXX_AVAILABLE AND CHRONO_CXX_FOUND)
  find_package(MPI COMPONENTS CXX QUIET)
  if(MPI_CXX_FOUND)
    if(NOT Chrono_FIND_QUIETLY)
      message(STATUS "MPI found")
    endif()
    set(CHRONO_MPI_CXX_FOUND TRUE)
  else()
    if(NOT Chrono_FIND_QUIETLY)
      message("WARNING: MPI not found")
    endif()
    set(CHRONO_MPI_CXX_FOUND FALSE)
  endif()
endif()

#-------------------------------------------------------------------------------
# Set variables with paths to data directories
#-------------------------------------------------------------------------------

# RADU TODO: where does 'data/' go in install tree if using configurations?
if (CHRONO_INSTALL_TREE)
  set(CHRONO_DATA_DIR "${CMAKE_CURRENT_LIST_DIR}/../data/")
  set(CHRONO_VEHICLE_DATA_DIR "${CMAKE_CURRENT_LIST_DIR}/../data/vehicle/")
  set(CHRONO_FSI_DATA_DIR "${CMAKE_CURRENT_LIST_DIR}/../data/fsi/")
  set(SYNCHRONO_DATA_DIR "${CMAKE_CURRENT_LIST_DIR}/../data/synchrono/")
else()
  set(CHRONO_DATA_DIR "@CH_BUILD_DATA@/")
  set(CHRONO_VEHICLE_DATA_DIR "@CH_BUILD_DATA@/vehicle/")
  set(CHRONO_FSI_DATA_DIR "@CH_BUILD_DATA@/fsi/")
  set(SYNCHRONO_DATA_DIR "@CH_BUILD_DATA@/synchrono/")
endif()

#-------------------------------------------------------------------------------
# Initialize output variables for the core Chrono module (always present)
#-------------------------------------------------------------------------------

list(PREPEND CHRONO_LIB_NAMES "Chrono_core")
list(PREPEND CHRONO_LIB_NAMES "ChronoModels_robot")
if (NOT CHRONO_STATIC)
  list(APPEND CHRONO_DLL_NAMES "Chrono_core.dll")
  list(APPEND CHRONO_DLL_NAMES "ChronoModels_robot.dll")
endif()

#-------------------------------------------------------------------------------
# Loop over the list of requested components
#-------------------------------------------------------------------------------

if(NOT Chrono_FIND_QUIETLY)
  message(STATUS "Requested components")
endif()

set(Chrono_FOUND ON)

foreach(COMPONENT_UPPER ${Chrono_COMPONENTS})

  # Report the name of the component that was requested and whether it was required or optional
  if(NOT Chrono_FIND_QUIETLY)
    if(Chrono_${COMPONENT_UPPER}_REQUIRED)
      message(STATUS "  ${COMPONENT_UPPER} (REQUIRED)")
    else()
      message(STATUS "  ${COMPONENT_UPPER} (OPTIONAL)")
    endif()
  endif()

  # If the component is not available, stop if it is required or skip if it is optional
  if(NOT Chrono_${COMPONENT_UPPER}_AVAILABLE)
    set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)

    if(Chrono_${COMPONENT_UPPER}_REQUIRED)
       message(FATAL_ERROR "ERROR: Chrono was not configured with support for the REQUIRED component ${COMPONENT_UPPER}")
       set(Chrono_FOUND OFF)
       return()
    else()
       message("WARNING: Chrono was not configured with support for the OPTIONAL component ${COMPONENT_UPPER}")
       continue()
    endif()
  endif()

  # The component is available

  set(CHRONO_${COMPONENT_UPPER}_FOUND ON)

  if(${COMPONENT_UPPER} MATCHES "OPENGL")

    set(OpenGL_DIR "@OpenGL_DIR@" CACHE PATH "Path to the OpenGL installation.")
    set(GLEW_DIR "@GLEW_DIR@" CACHE PATH "Path to GLEW installation.")
    set(glfw3_DIR "@glfw3_DIR@" CACHE PATH "Path to glfw3 installation.")
    set(glm_DIR "@glm_DIR@" CACHE PATH "Path to glm installation.")
    find_package(OpenGL QUIET)
    find_package(GLEW QUIET)
    find_package(glfw3 QUIET)
    find_package(glm QUIET)

    if(NOT OPENGL_FOUND)
      mark_as_advanced(CLEAR OpenGL_DIR)
    else()
      mark_as_advanced(FORCE OpenGL_DIR)
    endif()

    if (NOT GLEW_FOUND)
      message("WARNING: Chrono::OpenGL requires GLEW, but GLEW was not found. Set GLEW_DIR to the GLEW installa directory.")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR GLEW_DIR)
    else()
      mark_as_advanced(FORCE GLEW_DIR)
    endif()
    
    if (NOT glfw3_FOUND)
      message("WARNING: Chrono::OpenGL requires glfw3, but glfw3 was not found. Set glfw3_DIR to the glfw install directory.")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR glfw3_DIR)
    else()
      mark_as_advanced(FORCE glfw3_DIR)
    endif()

    if (NOT glm_FOUND)
      message("WARNING: Chrono::OpenGL requires GLM, but GLM was not found. Set glm_DIR to the GLM install directory.")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR glm_DIR)
    else()
      mark_as_advanced(FORCE glm_DIR)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_opengl")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_opengl.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "MULTICORE")

    if (NOT CHRONO_THRUST_FOUND)
      message("WARNING: Chrono::Multicore requires Thrust, but Thrust was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

    if (NOT CHRONO_OPENMP_CXX_FOUND)
      message("WARNING: Chrono::Multicore requires OpenMP for C++, but OpenMP was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

    set(blaze_INCLUDE_DIR "@blaze_INCLUDE_DIR@" CACHE PATH "Path to Blaze include directory (should contain a subdirectory 'blaze')")
    find_package(Blaze QUIET)

    if (NOT blaze_FOUND)
      message("WARNING: Chrono::Multicore requires Blaze, but Blaze was not found; set blaze_INCLUDE_DIR or blaze_DIR")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR blaze_INCLUDE_DIR)
      mark_as_advanced(CLEAR blaze_DIR)
    else()
      mark_as_advanced(FORCE blaze_INCLUDE_DIR)
      mark_as_advanced(FORCE blaze_DIR)
    endif()    

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_multicore")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_multicore.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "MODAL")

    set(spectra_INCLUDE_DIR "@spectra_INCLUDE_DIR@" CACHE PATH "Path to Spectra include directory (should contain a subdirectory 'Spectra')")
    find_package(Spectra QUIET)

    if (NOT spectra_FOUND)
      message("WARNING: Chrono::modal requires Spectra, but Spectra was not found; set spectra_INCLUDE_DIR or spectra_DIR")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR spectra_INCLUDE_DIR)
      mark_as_advanced(CLEAR spectra_DIR)
    else()
      mark_as_advanced(FORCE spectra_INCLUDE_DIR)
      mark_as_advanced(FORCE spectra_DIR)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_modal")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_modal.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "IRRLICHT")

    set(Irrlicht_INCLUDE_DIR "@CH_IRRLICHT_INCLUDE_DIR@" CACHE STRING "Irrlicht include directory")
    set(Irrlicht_LIBRARY "@CH_IRRLICHT_LIBRARY@" CACHE STRING "Irrlicht library")
    find_package(Irrlicht QUIET)

    if (NOT Irrlicht_FOUND)
      message("WARNING: Could not find Irrlicht library; set Irrlicht_INCLUDE_DIRS and Irrlicht_LIBRARIES or Irrlicht_ROOT.")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR Irrlicht_INCLUDE_DIRS)
      mark_as_advanced(CLEAR Irrlicht_LIBRARIES)
    else()
      mark_as_advanced(FORCE Irrlicht_INCLUDE_DIRS)
      mark_as_advanced(FORCE Irrlicht_LIBRARIES)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_irrlicht")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_irrlicht.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "VSG")

    if(NOT CHRONO_CXX_FOUND)
      message("WARNING: Chrono::VSG requires C++, but C++ language was not enabled")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    else()
      set(vsg_DIR "@vsg_DIR@" CACHE PATH "Path to vsg installation.")
      set(vsgImGui_DIR "@vsgImGui_DIR@" CACHE PATH "Path to vsgImGui installation.")
      set(vsgXchange_DIR "@vsgXchange_DIR@" CACHE PATH "Path to vsgXchange installation.")
      find_package(vsg QUIET)
      find_package(vsgImGui QUIET)
      find_package(vsgXchange QUIET)
      
      if(NOT vsg_FOUND OR NOT vsgImGui_FOUND OR NOT vsgXchange_FOUND)
        message("WARNING: Could not find one of the VSG libraries")
        set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      endif()
      
      if (CHRONO_${COMPONENT_UPPER}_FOUND)
        list(PREPEND CHRONO_LIB_NAMES "Chrono_vsg")
        if (NOT CHRONO_STATIC)
          list(APPEND CHRONO_DLL_NAMES "Chrono_vsg.dll")
        endif()
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "VEHICLE")

    list(PREPEND CHRONO_LIB_NAMES "Chrono_vehicle")
    if (NOT CHRONO_STATIC)
      list(APPEND CHRONO_DLL_NAMES "Chrono_vehicle.dll")
    endif()
    list(PREPEND CHRONO_LIB_NAMES "ChronoModels_vehicle")
    if (NOT CHRONO_STATIC)
      list(APPEND CHRONO_DLL_NAMES "ChronoModels_vehicle.dll")
    endif()

    if(Chrono_IRRLICHT_REQUESTED AND Chrono_IRRLICHT_AVAILABLE)
      if(@HAVE_IRRKLANG@)
        set(IRRKLANG_ROOT "@IRRKLANG_ROOT@")
        set(IRRKLANG_LIBDIR "@IRRKLANG_LIBDIR@")
        find_package(IRRKLANG QUIET)
        if (NOT IRRKLANG_FOUND)
          if(NOT Chrono_FIND_QUIETLY)
              message(STATUS "Chrono_vehicle_irrlicht was built with IrrKlang that has not been found. Chrono_vehicle_irrlicht will not be enabled.")
          endif()
        endif()
      endif()

      if (NOT @HAVE_IRRKLANG@ OR IRRKLANG_FOUND)
        list(PREPEND CHRONO_LIB_NAMES "Chrono_vehicle_irrlicht")
        if (NOT CHRONO_STATIC)
          list(APPEND CHRONO_DLL_NAMES "Chrono_vehicle_irrlicht.dll")
        endif()
      endif()

    endif()

    if(Chrono_VSG_REQUESTED AND Chrono_VSG_AVAILABLE)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_vehicle_vsg")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_vehicle_vsg.dll")
      endif()
    endif()

    if(Chrono_VEHICLECOSIM_REQUESTED AND Chrono_VEHICLECOSIM_AVAILABLE)
      
      if(NOT CHRONO_MPI_CXX_FOUND)
        message("WARNING: Chrono::Vehicle co-sim requires MPI for C++, but MPI was not found")
        set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      else()
        list(PREPEND CHRONO_LIB_NAMES "Chrono_vehicle_cosim")
        if (NOT CHRONO_STATIC)
          list(APPEND CHRONO_DLL_NAMES "Chrono_vehicle_cosim.dll")
        endif()
      endif()

    endif()

    set(CHRONO_VEHICLE_IRRKLANG @HAVE_IRRKLANG@)
    set(CHRONO_VEHICLE_OPENCRG @HAVE_OPENCRG@)

  elseif(${COMPONENT_UPPER} MATCHES "FSI")
    
    if(NOT CHRONO_CUDA_FOUND)
      message("WARNING: Chrono::FSI requires Cuda, but Cuda was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

    if(NOT CHRONO_THRUST_FOUND)
      message("WARNING: Chrono::FSI requires Thrust, but Thrust was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)

      list(PREPEND CHRONO_LIB_NAMES "Chrono_fsisph")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_fsisph.dll")
      endif()

      if(Chrono_VSG_REQUESTED AND Chrono_VSG_AVAILABLE)
        list(PREPEND CHRONO_LIB_NAMES "Chrono_fsisph_vsg")
        if (NOT CHRONO_STATIC)
          list(APPEND CHRONO_DLL_NAMES "Chrono_fsisph_vsg.dll")
        endif()
      endif()

      if(Chrono_OPENGL_REQUESTED AND Chrono_OPENGL_AVAILABLE)
        list(PREPEND CHRONO_LIB_NAMES "Chrono_fsisph_opengl")
        if (NOT CHRONO_STATIC)
          list(APPEND CHRONO_DLL_NAMES "Chrono_fsisph_opengl.dll")
        endif()
      endif()

      # ATTENTION: This is a temporary hack!
      # We only add to the list of DLLs, when we should fully configure the OpenGL and VSG modules.
      # However, full configuration of the OpenGL module leads to problems when using in a C# project (because of FindThreads).
      # This is done only to allow building vehicle C# demos, in case the FSI module was also enabled in Chrono.
      if (NOT CHRONO_STATIC)
        if (Chrono_OPENGL_AVAILABLE)
          list(APPEND CHRONO_DLL_NAMES "Chrono_opengl.dll")
          list(APPEND CHRONO_DLL_NAMES "Chrono_fsisph_opengl.dll")
        endif()
        if (Chrono_VSG_AVAILABLE)
          list(APPEND CHRONO_DLL_NAMES "Chrono_vsg.dll")
          list(APPEND CHRONO_DLL_NAMES "Chrono_fsisph_vsg.dll")
        endif()
      endif()

    endif()

  elseif(${COMPONENT_UPPER} MATCHES "SENSOR")

    set(OptiX_INSTALL_DIR "@OptiX_ROOT_DIR@" CACHE PATH "Path to the installed location of the OptiX SDK.")
    find_package(OptiX QUIET)

    if(NOT OptiX_FOUND)
      message("WARNING: Chrono::Sensor requires OptiX, but Optix was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR OptiX_INSTALL_DIR)
    else()
      mark_as_advanced(FORCE OptiX_INSTALL_DIR)
    endif()

    set(OpenGL_DIR "@OpenGL_DIR@" CACHE PATH "Path to the OpenGL installation.")
    set(GLEW_DIR "@GLEW_DIR@" CACHE PATH "Path to the GLEW installation.")
    set(glfw3_DIR "@glfw3_DIR@" CACHE PATH "Path to the glfw3 installation.")
    find_package(OpenGL QUIET)
    find_package(GLEW QUIET)
    find_package(glfw3 QUIET)

    if(OPENGL_FOUND AND GLEW_FOUND AND glfw3_FOUND)
      mark_as_advanced(CLEAR OpenGL_DIR)
      mark_as_advanced(CLEAR GLEW_DIR)
      mark_as_advanced(CLEAR glfw3_DIR)
    else()
      message("WARNING: Chrono::Sensor GL libraries not found; OpenGL support disabled")
      mark_as_advanced(FORCE OpenGL_DIR)
      mark_as_advanced(FORCE GLEW_DIR)
      mark_as_advanced(FORCE glfw3_DIR)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_sensor")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_sensor.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "SYNCHRONO")

    set(CHRONO_SYNCHRONO_FASTDDS @FASTDDS_FOUND@)

    if(NOT CHRONO_MPI_CXX_FOUND)
      message("WARNING: Chrono::Synchrono requires MPI, but MPI was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

    if(@FASTDDS_FOUND@)
      # TODO: no fastcdr?
      set(fastrtps_DIR "@fastrtps_DIR@" CACHE PATH "Path to FastDDS installation")
      find_package(fastrtps QUIET)
      if (NOT fastrtps_FOUND)
        message("WARNING: Chrono::Synchrono was compiled with FastDDS, but FastDDS has not been found on this machine.")
        set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
        mark_as_advanced(CLEAR fastrtps_DIR)
      else()
        mark_as_advanced(FORCE fastrtps_DIR)
      endif()
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_synchrono")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_synchrono.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "ROS")

    set(rclcpp_DIR "@rclcpp_DIR@" CACHE PATH "Path to rclcpp installation")
    set(tf2_ros_DIR "@tf2_ros_DIR@" CACHE PATH "Path to tf2_ros installation")
    set(rcl_interfaces_DIR "@rcl_interfaces_DIR@" CACHE PATH "Path to rcl_interfaces installation")
    set(std_msgs_DIR "@std_msgs_DIR@" CACHE PATH "Path to std_msgs installation")
    set(geometry_msgs_DIR "@geometry_msgs_DIR@" CACHE PATH "Path to geometry_msgs installation")
    set(sensor_msgs_DIR "@sensor_msgs_DIR@" CACHE PATH "Path to sensor_msgs installation")
    set(tf2_msgs_DIR "@tf2_msgs_DIR@" CACHE PATH "Path to tf2_msgs installation")
    find_package(rclcpp QUIET)
    find_package(tf2_ros QUIET)
    find_package(rcl_interfaces QUIET)
    find_package(std_msgs QUIET)
    find_package(geometry_msgs QUIET)
    find_package(sensor_msgs QUIET)
    find_package(tf2_msgs QUIET)

    if(rclcpp_FOUND AND tf2_ros_FOUND AND rcl_interfaces_FOUND AND std_msgs_FOUND AND geometry_msgs_FOUND AND sensor_msgs_FOUND AND tf2_msgs_FOUND)
      mark_as_advanced(FORCE rclcpp_DIR)
      mark_as_advanced(FORCE tf2_ros_DIR)
      mark_as_advanced(FORCE rcl_interfaces_DIR)
      mark_as_advanced(FORCE std_msgs_DIR)
      mark_as_advanced(FORCE geometry_msgs_DIR)
      mark_as_advanced(FORCE sensor_msgs_DIR)
      mark_as_advanced(FORCE tf2_msgs_DIR)
    else()
      message("WARNING: Chrono::ROS requires ROS 2, but ROS 2 was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR rclcpp_DIR)
      mark_as_advanced(CLEAR tf2_ros_DIR)
      mark_as_advanced(CLEAR rcl_interfaces_DIR)
      mark_as_advanced(CLEAR std_msgs_DIR)
      mark_as_advanced(CLEAR geometry_msgs_DIR)
      mark_as_advanced(CLEAR sensor_msgs_DIR)
      mark_as_advanced(CLEAR tf2_msgs_DIR)
    endif()

    if (@CH_ROS_HAS_INTERFACES@)
      set(chrono_ros_interfaces_DIR "@chrono_ros_interfaces_DIR@" CACHE PATH "Path to chrono_ros_interfaces installation")
      find_package(chrono_ros_interfaces QUIET)

      if(chrono_ros_interfaces_FOUND)
        mark_as_advanced(FORCE chrono_ros_interfaces_DIR)
      else()
        set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
        message("WARNING: Chrono::ROS was compiled with interfaces, but chrono_ros_interfaces has not been found on this machine. Disabling Chrono::ROS.")
        mark_as_advanced(CLEAR chrono_ros_interfaces_DIR)
      endif()
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_ros")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_ros.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "GPU")

    if(NOT CHRONO_CUDA_FOUND)
      message("WARNING: Chrono::GPU requires Cuda, but Cuda was not found")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)

      list(PREPEND CHRONO_LIB_NAMES "Chrono_gpu")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_gpu.dll")
      endif()

      if(Chrono_OPENGL_REQUESTED AND Chrono_OPENGL_AVAILABLE)
        list(PREPEND CHRONO_LIB_NAMES "Chrono_gpu_opengl")
        if (NOT CHRONO_STATIC)
          list(APPEND CHRONO_DLL_NAMES "Chrono_gpu_opengl.dll")
        endif()
      endif()

    endif()

  elseif(${COMPONENT_UPPER} MATCHES "PARDISOMKL")

    # TODO: DARIOM not sure if we should force the consumer to link against MKL using exactly the same settings as the main Chrono library
    if(NOT MKL_ROOT)
      set(MKL_ROOT "@MKL_ROOT@")
    endif()

    if(NOT MKL_ARCH)
      set(MKL_ARCH "@MKL_ARCH@")
    endif()

    if(NOT MKL_LINK)
      set(MKL_LINK "@MKL_LINK@")
    endif()

    if(NOT MKL_THREADING)
      set(MKL_THREADING "@MKL_THREADING@")
    endif()

    if(NOT MKL_INTERFACE)
      set(MKL_INTERFACE "@MKL_INTERFACE@")
    endif()

    if(NOT MKL_MPI)
      set(MKL_MPI "@MKL_MPI@")
    endif()

    if(NOT TARGET MKL::MKL)
      find_package(MKL CONFIG QUIET)
    elseif(NOT Chrono_FIND_QUIETLY)
      message(STATUS "MKL::MKL already available.")
    endif()

    if(TARGET MKL::MKL)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_pardisomkl")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_pardisomkl.dll")
      endif()
    else()
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "MUMPS")

    set(MUMPS_DIR "@MUMPS_DIR@" CACHE PATH "Path to MUMPS installation.")
    find_package(MUMPS QUIET)

    if(NOT MUMPS_FOUND)
      message("WARNING Could not find MUMPS")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_mumps")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_mumps.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "POSTPROCESS")

    list(PREPEND CHRONO_LIB_NAMES "Chrono_postprocess")
    if (NOT CHRONO_STATIC)
      list(APPEND CHRONO_DLL_NAMES "Chrono_postprocess.dll")
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "CASCADE")
    

    set(OpenCASCADE_DIR "@OpenCASCADE_DIR@" CACHE PATH "The directory containing a CMake configuration for OpenCASCADE")
    find_package(OpenCASCADE QUIET)

    if (NOT OpenCASCADE_FOUND)
      message("WARNING: Could not find OpenCASCADE")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
    else()
      list(PREPEND CHRONO_LIB_NAMES "Chrono_cascade")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_cascade.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "PARSERS")

  
    set(CHRONO_PARSERS_PYTHON @HAVE_PYTHON@)
    set(CHRONO_PARSERS_URDF @HAVE_URDF@)

    list(PREPEND CHRONO_LIB_NAMES "Chrono_parsers")
    if (NOT CHRONO_STATIC)
      list(APPEND CHRONO_DLL_NAMES "Chrono_parsers.dll")
    endif()

    if(@HAVE_URDF@)
      set(urdfdom_DIR "@urdfdom_DIR@" CACHE PATH "The directory containing a CMake configuration for urdfdom")
      set(urdfdom_headers_DIR "@urdfdom_headers_DIR@" CACHE PATH "The directory containing a CMake configuration for urdfdom_headers")
      set(console_bridge_DIR "@console_bridge_DIR@" CACHE PATH "The directory containing a CMake configuration for console_bridge")
      set(tinyxml2_DIR "@tinyxml2_DIR@" CACHE PATH "The directory containing a CMake configuration for tinyxml2")
      find_package(urdfdom REQUIRED)
      find_package(urdfdom_headers REQUIRED)
      find_package(console_bridge REQUIRED)
      find_package(tinyxml2 REQUIRED)

      if(urdfdom_FOUND AND urdfdom_headers_FOUND AND console_bridge_FOUND AND tinyxml2_FOUND)
        mark_as_advanced(FORCE urdfdom_DIR)
        mark_as_advanced(FORCE urdfdom_headers_DIR)
        mark_as_advanced(FORCE console_bridge_DIR)
        mark_as_advanced(FORCE tinyxml2_DIR)
      else()
        message("WARNING: Chrono::parsers has been built with URDF, but URDF dependencies were not found on this machine. Disabling it.")
        set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
        mark_as_advanced(CLEAR urdfdom_DIR)
        mark_as_advanced(CLEAR urdfdom_headers_DIR)
        mark_as_advanced(CLEAR console_bridge_DIR)
        mark_as_advanced(CLEAR tinyxml2_DIR)
      endif()
    endif()


  elseif(${COMPONENT_UPPER} MATCHES "MATLAB")

    set(Matlab_ROOT_DIR "@Matlab_ROOT_DIR@" CACHE PATH "Matlab installation root path.")
    find_package(Matlab COMPONENTS MAT_LIBRARY ENG_LIBRARY QUIET)

    if(NOT Matlab_FOUND)
      message("WARNING: Could not find Matlab.")
      set(CHRONO_${COMPONENT_UPPER}_FOUND OFF)
      mark_as_advanced(CLEAR Matlab_ROOT_DIR)
    else()
      mark_as_advanced(FORCE Matlab_ROOT_DIR)
    endif()

    if (CHRONO_${COMPONENT_UPPER}_FOUND)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_matlab")
      if (NOT CHRONO_STATIC)
        list(APPEND CHRONO_DLL_NAMES "Chrono_matlab.dll")
      endif()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "CSHARP")

    set(CHRONO_VERSION @CHRONO_VERSION@)

    function(FindDuplicates ret_list list1 list2)
      # Union of list1 and list2
      list(APPEND union ${list1} ${list2})
      list(REMOVE_DUPLICATES union)

      # Difference 1 - 2
      list(APPEND diff_12 ${list1})
      list(REMOVE_ITEM diff_12 ${list2})

      # Difference 2 -1
      list(APPEND diff_21 ${list2})
      list(REMOVE_ITEM diff_21 ${list1})

      # Calculate union of (1-2) and (2-1)
      list(APPEND delta ${diff_12} ${diff_21})
      list(REMOVE_DUPLICATES delta)

      # Calculate the intersection as union-delta
      list(APPEND intersection ${union})
      list(REMOVE_ITEM intersection ${delta})

      set(${ret_list} "${intersection}" PARENT_SCOPE)
    endfunction()

    list(PREPEND CHRONO_LIB_NAMES "Chrono_csharp_core")
    list(APPEND CHRONO_DLL_NAMES "Chrono_csharp_core.dll") # valid also in case of static

    set(CHRONO_CSHARP_SOURCE_DIR "${CMAKE_CURRENT_LIST_DIR}/../chrono_csharp")
    
    # Create ChChronoGlobals.cs based on current location
    set(CH_CS_DATA ${CHRONO_DATA_DIR})
    set(CH_CS_VEHICLE_DATA ${CHRONO_VEHICLE_DATA_DIR})
    configure_file("${CMAKE_CURRENT_LIST_DIR}/ChChronoGlobals.cs.in"
                   "${CHRONO_CSHARP_SOURCE_DIR}/core/ChChronoGlobals.cs"
                   @ONLY)

    set(Chrono_CSHARP_CORE_DIR "${CHRONO_CSHARP_SOURCE_DIR}/core")
    file(GLOB Chrono_CSHARP_CORE_SOURCES 
         LIST_DIRECTORIES false 
         RELATIVE "${Chrono_CSHARP_CORE_DIR}" 
         CONFIGURE_DEPENDS 
         "${Chrono_CSHARP_CORE_DIR}/*.cs")
    foreach(CS ${Chrono_CSHARP_CORE_SOURCES})
       list(APPEND CHRONO_CSHARP_SOURCES "${Chrono_CSHARP_CORE_DIR}/${CS}")
    endforeach()
    
    if(Chrono_IRRLICHT_REQUESTED AND Chrono_IRRLICHT_AVAILABLE)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_csharp_irrlicht")
      list(APPEND CHRONO_DLL_NAMES "Chrono_csharp_irrlicht.dll")

      set(Chrono_CSHARP_IRRLICHT_DIR "${CHRONO_CSHARP_SOURCE_DIR}/irrlicht")
      file(GLOB Chrono_CSHARP_IRRLICHT_SOURCES
           LIST_DIRECTORIES false
           RELATIVE "${Chrono_CSHARP_IRRLICHT_DIR}"
           CONFIGURE_DEPENDS
           "${Chrono_CSHARP_IRRLICHT_DIR}/*.cs")
      FindDuplicates(Chrono_CSHARP_IRRLICHT_DUPLICATES "${Chrono_CSHARP_CORE_SOURCES}"
                                                       "${Chrono_CSHARP_IRRLICHT_SOURCES}")
      list(REMOVE_ITEM Chrono_CSHARP_IRRLICHT_SOURCES ${Chrono_CSHARP_IRRLICHT_DUPLICATES})
      foreach(CS ${Chrono_CSHARP_IRRLICHT_SOURCES})
        list(APPEND CHRONO_CSHARP_SOURCES "${Chrono_CSHARP_IRRLICHT_DIR}/${CS}")
      endforeach()
    endif()

    if(Chrono_VEHICLE_REQUESTED AND Chrono_VEHICLE_AVAILABLE)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_csharp_vehicle")
      list(APPEND CHRONO_DLL_NAMES "Chrono_csharp_vehicle.dll")

      set(Chrono_CSHARP_VEHICLE_DIR "${CHRONO_CSHARP_SOURCE_DIR}/vehicle")
      file(GLOB Chrono_CSHARP_VEHICLE_SOURCES
           LIST_DIRECTORIES false
           RELATIVE "${Chrono_CSHARP_VEHICLE_DIR}"
           CONFIGURE_DEPENDS
           "${Chrono_CSHARP_VEHICLE_DIR}/*.cs")
      FindDuplicates(Chrono_CSHARP_VEHICLE_DUPLICATES "${Chrono_CSHARP_CORE_SOURCES}"
                                                      "${Chrono_CSHARP_VEHICLE_SOURCES}")
      list(REMOVE_ITEM Chrono_CSHARP_VEHICLE_SOURCES ${Chrono_CSHARP_VEHICLE_DUPLICATES})
      foreach(CS ${Chrono_CSHARP_VEHICLE_SOURCES})
        list(APPEND CHRONO_CSHARP_SOURCES "${Chrono_CSHARP_VEHICLE_DIR}/${CS}")
      endforeach()
    endif() 

    if(Chrono_POSTPROCESS_REQUESTED AND Chrono_POSTPROCESS_AVAILABLE)
      list(PREPEND CHRONO_LIB_NAMES "Chrono_csharp_postprocess")
      list(APPEND CHRONO_DLL_NAMES "Chrono_csharp_postprocess.dll")

      set(Chrono_CSHARP_POSTPROCESS_DIR "${CHRONO_CSHARP_SOURCE_DIR}/postprocess")
      file(GLOB Chrono_CSHARP_POSTPROCESS_SOURCES 
           LIST_DIRECTORIES false 
           RELATIVE "${Chrono_CSHARP_POSTPROCESS_DIR}" 
           CONFIGURE_DEPENDS 
           "${Chrono_CSHARP_POSTPROCESS_DIR}/*.cs")
      FindDuplicates(Chrono_CSHARP_POSTPROCESS_DUPLICATES "${Chrono_CSHARP_CORE_SOURCES}"
                                                          "${Chrono_CSHARP_POSTPROCESS_SOURCES}")
      list(REMOVE_ITEM Chrono_CSHARP_POSTPROCESS_SOURCES ${Chrono_CSHARP_POSTPROCESS_DUPLICATES})
      foreach(CS ${Chrono_CSHARP_POSTPROCESS_SOURCES})
         list(APPEND CHRONO_CSHARP_SOURCES "${Chrono_CSHARP_POSTPROCESS_DIR}/${CS}")
      endforeach()
    endif()

  elseif(${COMPONENT_UPPER} MATCHES "FMI")
    
    if (CHRONO_INSTALL_TREE)
      set(CHRONO_FMU_TOOLS_DIR "${CHRONO_PACKAGE_PREFIX_DIR}include/chrono_thirdparty/fmu_tools")
    else()
      set(CHRONO_FMU_TOOLS_DIR "@FMU_TOOLS_DIR@")
    endif()
    
    list(PREPEND CHRONO_LIB_NAMES "Chrono_fmi")
    if (NOT CHRONO_STATIC)
      list(APPEND CHRONO_DLL_NAMES "Chrono_fmi.dll")
    endif()

  endif() # end if-else for component type

  # Check if the 
  if (NOT CHRONO_${COMPONENT_UPPER}_FOUND)
    if(Chrono_${COMPONENT_UPPER}_REQUIRED)
      message(FATAL_ERROR "ERROR: Chrono was not configured with support for the REQUIRED component ${COMPONENT_UPPER}")
      set(Chrono_FOUND OFF)
      return()
    else()
      message("WARNING: Chrono was not configured with support for the OPTIONAL component ${COMPONENT_UPPER}")
      continue()
    endif()
  endif()

endforeach()


#-------------------------------------------------------------------------------
# Loop over list of Chrono library names and find the actual libraries.
#-------------------------------------------------------------------------------

get_property(IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(NOT CHRONO_CONFIGURATION_TYPES)
  if(IS_MULTI_CONFIG)
    set(CHRONO_CONFIGURATION_TYPES ${CMAKE_CONFIGURATION_TYPES}) # system has multi-config IDE
  else()
    if(CMAKE_BUILD_TYPE)
      set(CHRONO_CONFIGURATION_TYPES "${CMAKE_BUILD_TYPE}")
    else()
      set(CHRONO_CONFIGURATION_TYPES "Default")
    endif()
  endif()
endif()

if(${CMAKE_SYSTEM_NAME} MATCHES "Emscripten")
    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER)
endif()

foreach(config ${CHRONO_CONFIGURATION_TYPES})
  string(TOUPPER config config_upper)
  foreach(lib ${CHRONO_LIB_NAMES})
    set(onelib "${lib}-NOTFOUND")
    find_library(onelib ${lib}
      PATHS "${CHRONO_PACKAGE_PREFIX_DIR}/lib"
      PATH_SUFFIXES ${config}
      NO_DEFAULT_PATH
    )
    if(NOT onelib)
      list(APPEND CHRONO_MISSING_LIB_CONFIG_${config} ${lib})
    endif()
  endforeach()
endforeach()

unset(onelib CACHE)

#-------------------------------------------------------------------------------
# Check that necessary Chrono libraries exist
#-------------------------------------------------------------------------------

if (IS_MULTI_CONFIG)
  if(NOT Chrono_FIND_QUIETLY)
    message(STATUS "Chrono libraries for multi-config build systems")
  endif()
  foreach(config ${CHRONO_CONFIGURATION_TYPES})
    # if the given configuration does not have a proper Chrono built library then link to Chrono Release, but only for non-static
    if(NOT Chrono_FIND_QUIETLY)
      if (CHRONO_MISSING_LIB_CONFIG_${config})
        message(STATUS "  Configuration ${config} will not work properly since some Chrono libraries are missing for this configuration:\n      missing: ${CHRONO_MISSING_LIB_CONFIG_${config}}")
      else()
        message(STATUS "  Chrono libraries for configuration ${config} have been successfully found.")
      endif()
    endif()
  endforeach()
else()
  if (CHRONO_MISSING_LIB_CONFIG_${CHRONO_CONFIGURATION_TYPES})
    message(NOTICE "Some Chrono libraries are not installed properly: ${CHRONO_MISSING_LIB_CONFIG_${CHRONO_CONFIGURATION_TYPES}}")
  endif()
endif() 

if(${CMAKE_SYSTEM_NAME} MATCHES "Emscripten")
    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
endif()

# If not on Windows, clear the lists of DLLs
if(NOT ${CMAKE_SYSTEM_NAME} MATCHES "Windows")
  set(CHRONO_DLL_NAMES "")
endif()

#-------------------------------------------------------------------------------
# Create list of Chrono target names
#-------------------------------------------------------------------------------

foreach(lib ${CHRONO_LIB_NAMES})
  list(APPEND CHRONO_TARGETS "Chrono::${lib}")
endforeach()

unset(CHRONO_LIB_NAMES)

#-------------------------------------------------------------------------------
# Report the exported variables
#-------------------------------------------------------------------------------

if(NOT Chrono_FIND_QUIETLY)

  message(STATUS "Configuration summary")
  message(STATUS "  CHRONO_TARGETS           (Chrono targets): ${CHRONO_TARGETS}")
  message(STATUS "  CHRONO_DATA_DIR          (Path to Chrono data folder): ${CHRONO_DATA_DIR}")
  message(STATUS "  CHRONO_VEHICLE_DATA_DIR  (Path to Chrono::Vehicle data folder): ${CHRONO_VEHICLE_DATA_DIR}")
  message(STATUS "  CHRONO_FSI_DATA_DIR      (Path to Chrono::FSI data folder): ${CHRONO_FSI_DATA_DIR}")
  
  if(${CMAKE_SYSTEM_NAME} MATCHES "Windows")
    message(STATUS "  CHRONO_DLL_NAMES         (Chrono DLLs): ${CHRONO_DLL_NAMES}")
  endif()

endif()

#===============================================================================
# Provide a CMake function which adds a custom command (COPY_DLLS), invoked
# pre-build to copy all DLLs specified in the input list to the appropriate
# folder for the current VS configuration.
#
# The input list must contain a list of DLLs with full paths, such as that
# returned by the chrono-config script.
#===============================================================================

# Create custom commands, invoked pre-build to copy DLLs to the appropriate
# directory (depending on the configuration selected at build time in VS)

function(add_DLL_copy_command)

    # Return now if not windows
    if(NOT ${CMAKE_SYSTEM_NAME} MATCHES "Windows")
      return()
    endif()

    message(STATUS "\nAdd custom commands for copying DLLs")
    
    if(${ARGC} GREATER 0)
      message(STATUS "DLLs from provided list will be copied to runtime folder")
      set(DLL_NAMES ${ARGV0})
    else()
      message(STATUS "All libraries in CHRONO_DLL_NAMES (if found for the given configuration) will be copied automatically to runtime folder")
      set(DLL_NAMES ${CHRONO_DLL_NAMES})
    endif()

    get_property(IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
    if(NOT CHRONO_CONFIGURATION_TYPES)
      if(IS_MULTI_CONFIG)
        set(CHRONO_CONFIGURATION_TYPES ${CMAKE_CONFIGURATION_TYPES}) # system has multi-config IDE
      else()
        if(CMAKE_BUILD_TYPE)
          set(CHRONO_CONFIGURATION_TYPES "${CMAKE_BUILD_TYPE}")
        else()
          set(CHRONO_CONFIGURATION_TYPES "Release")
        endif()
      endif()
    endif()

    # Remove duplicates in lists
    list(REMOVE_DUPLICATES DLL_NAMES)

    # Find actual Chrono DLLs

    foreach(config ${CHRONO_CONFIGURATION_TYPES})
      unset(DLLS_${config})
      unset(DLL_MISSING_${config})
    endforeach()

    foreach(config ${CHRONO_CONFIGURATION_TYPES}) 
      foreach(dll ${DLL_NAMES})
        set(onedll "${dll}-NOTFOUND")
        find_file(onedll ${dll}
          PATHS "${CHRONO_PACKAGE_PREFIX_DIR}/bin"
          PATH_SUFFIXES "${config}"
          NO_DEFAULT_PATH
        )
        if(NOT onedll)
          list(APPEND DLL_MISSING_${config} ${dll})
          # message(STATUS "DLL '${dll}' in package Chrono is not installed properly")
        else()
          list(APPEND DLLS_${config} "${onedll}")
          # message(STATUS "...${onedll}")
        endif()
      endforeach()
    endforeach()  
    unset(onedll CACHE)
    
    # # if a given configuration is missing then the Release DLLs will be used as rollback for that given config
    # foreach(config ${CHRONO_CONFIGURATION_TYPES})
    #   if (DLL_MISSING_${config} AND NOT DLL_MISSING_Release)
    #     set(DLLS_${config} ${DLLS_Release})
    #   endif()
    # endforeach()

    # Create custom target for copying DLLs; add it to the default build target
    add_custom_target(COPY_DLLS ALL)

    # Grab the folder in which the given configuration will generate the files
    # this is not a per-target folder, but it assumed a commond folder for all the runtime artifacts for the entire project
    # unless otherwise specified through the CMAKE_RUNTIME_OUTPUT_DIRECTORY and CMAKE_RUNTIME_OUTPUT_DIRECTORY_<CONFIG> variables
    foreach(config ${CHRONO_CONFIGURATION_TYPES})
      string(TOUPPER ${config} config_upper)
      if(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${config_upper})
        set(TEMP_RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${CMAKE_RUNTIME_OUTPUT_DIRECTORY_${config_upper}}")
      else()
        if(CMAKE_RUNTIME_OUTPUT_DIRECTORY)
          set(TEMP_RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${config}/")
        else()
          set(TEMP_RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${PROJECT_BINARY_DIR}/${config}/")
        endif()
      endif()

      # Add custom command to create the destination folder
      add_custom_command(
        TARGET COPY_DLLS PRE_BUILD
        COMMENT "Creating DLL output directory ${TEMP_RUNTIME_OUTPUT_DIRECTORY_${config_upper}}\n"
        COMMAND "$<$<CONFIG:${config}>:${CMAKE_COMMAND}>"
            "$<$<CONFIG:${config}>:-E>"
            "$<$<CONFIG:${config}>:make_directory>"
            "$<$<CONFIG:${config}>:${TEMP_RUNTIME_OUTPUT_DIRECTORY_${config_upper}}>"
      )
    endforeach()

    # Add custom command for each Chrono DLL
    foreach(config ${CHRONO_CONFIGURATION_TYPES})
      string(TOUPPER ${config} config_upper)

      # copy Chrono DLLs in configuration-specific folder
      foreach(DLL ${DLLS_${config}})
          add_custom_command(
              TARGET COPY_DLLS POST_BUILD
              COMMENT "Copying Chrono DLL ${DLL} in ${TEMP_RUNTIME_OUTPUT_DIRECTORY_${config_upper}}\n"  
              COMMAND "$<$<CONFIG:${config}>:${CMAKE_COMMAND}>"
                  "$<$<CONFIG:${config}>:-E>"
                  "$<$<CONFIG:${config}>:copy_if_different>"
                  "$<$<CONFIG:${config}>:${DLL}>"
                  "$<$<CONFIG:${config}>:${TEMP_RUNTIME_OUTPUT_DIRECTORY_${config_upper}}>"
          )
      endforeach()

    endforeach()
    unset(TEMP_RUNTIME_OUTPUT_DIRECTORY_CONFIG)
    unset(config_upper)

    message(STATUS "")

endfunction()



check_required_components(Chrono_core)
