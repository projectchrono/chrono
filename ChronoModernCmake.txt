- verify is package_DIR or package_ROOT should be used
- use (and install) FindCudaArch or find better alternative (see https://cmake.org/cmake/help/latest/command/find_package.html#find-package)
- the copy of DLLs is currently not working; re-enable it
- cleanup log of both Chrono and Chrono project CMake
- target_link_librarie should PRIVATE or PUBLIC link to main ChronoEngine? What about other sublibraries with its dependencies
- some flags guarded by <COMPILE_LANGUAGE:CXX> might be fed also to <COMPILE_LANGUAGE:CUDA>-Xcompile; so far only /Zc:__cplusplus was manually replicated: shall we automatize the process by grabbing all CXX flags and automatically populate CUDA host compiler flags? are all needed or shall we just cherry-pick them?
- as glew dll I only have "C:\workspace\libraries\gl\bin\glew32d.dll" that ends with d. Is it debug? did I install it properly?
- rename ChronoEngine:: to Chrono::
- BUILD_SHARED_LIBS might|should be replaced by a per-project variable?
- update GLM
- temporarily suppress CUDA deprecation warnings? [DONE}
- check all PRIVATE|PUBLIC linked libraries
- if a given target (e.g. vehicle) requires a subcomponent (e.g. FSI), do we need in chrono-config.cmake to just add an additional FSI DLL or also the dependencies of FSI i.e. requiring FSI as FIND component?
- warning about C# in chrono-config
- check find_dependency over find_package in chrono-config.cmake
- extends FindOpenCRG to get different config types
- check if INCLUDE DESTINATION in INSTALL is sufficient or if needed: install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/ DESTINATION include/chrono_models/robot FILES_MATCHING PATTERN "*.h")
- reenable version in CMake
- in demo_PARSER_Python_SolidWorks added check about existance of PyChrono
- use consistently either pardiso_mkl or pardisomkl
- update USE_TENSOR_RT
- check AVX2 not actually passed to compiler