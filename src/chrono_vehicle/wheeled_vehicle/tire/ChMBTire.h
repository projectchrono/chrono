// =============================================================================
// PROJECT CHRONO - http://projectchrono.org
//
// Copyright (c) 2023 projectchrono.org
// All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file at the top level of the distribution and at
// http://projectchrono.org/license-chrono.txt.
//
// =============================================================================
// Authors: Radu Serban
// =============================================================================
//
// Template for a multibody deformable tire.
//
// =============================================================================

#ifndef CH_MB_TIRE_H
#define CH_MB_TIRE_H

#include "chrono/fea/ChNodeFEAxyz.h"
#include "chrono/solver/ChKRMBlock.h"

#include "chrono_vehicle/wheeled_vehicle/tire/ChDeformableTire.h"

namespace chrono {
namespace vehicle {

class MBTireModel;

/// @addtogroup vehicle_wheeled_tire
/// @{

/// Template for a multibody deformable tire.
class CH_VEHICLE_API ChMBTire : public ChDeformableTire {
  public:
    ChMBTire(const std::string& name);
    virtual ~ChMBTire() {}

    /// Get the name of the vehicle subsystem template.
    virtual std::string GetTemplateName() const override { return "MBTire"; }

    /// Set the tire geometry.
    void SetTireGeometry(const std::vector<double>& ring_radii,    ///< radii of node rings
                         const std::vector<double>& ring_offsets,  ///< transversal offsets of node rings
                         int num_divs,                             ///< number of divisions in circumferential direction
                         double rim_radius                         ///< radius of wheel rim
    );

    /// Set the total tire mass.
    void SetTireMass(double mass);

    /// Set stiffness and damping coefficients for translational mesh springs.
    void SetMeshSpringCoefficients(double kC,  ///< circumferential spring elastic coefficient
                                   double cC,  ///< circumferential spring damping coefficient
                                   double kT,  ///< transversal spring elastic coefficient
                                   double cT   ///< transversal spring damping coefficient
    );

    /// Set stiffness and damping coefficients for rotational bending springs.
    void SetBendingSpringCoefficients(double kB,  ///< torsional spring elastic coefficient
                                      double cB   ///< torsional spring damping coefficient
    );

    /// Set stiffness and damping coefficients for radial springs.
    void SetRadialSpringCoefficients(double kR,  ///< radial spring elastic coefficient
                                     double cR   ///< radial spring damping coefficient
    );

    /// Declare the forces generated by this element as stiff (default: false).
    /// If stiff, Jacobian information will be generated.
    void IsStiff(bool val);

    /// Force Jacobian calculation for debugging purposes (default: false).
    /// Note that the Jacobian is used in integratino only if the tire element is declared stiff.
    void ForceJacobianCalculation(bool val);

    /// Set contact material properties.
    void SetTireContactMaterial(const ChContactMaterialData& mat_data);

    /// Get the tire radius.
    virtual double GetRadius() const override final;

    /// Get the rim radius (inner tire radius).
    virtual double GetRimRadius() const override final;

    /// Get the tire width.
    virtual double GetWidth() const override final;

    /// Report the tire force and moment.
    virtual TerrainForce ReportTireForce(ChTerrain* terrain) const override;

    /// Get the tire force and moment expressed in the tire frame.
    /// Currently *NOT IMPLEMENTED*.
    virtual TerrainForce ReportTireForceLocal(ChTerrain* terrain, ChCoordsys<>& tire_frame) const override;

    /// Add visualization assets for the tire subsystem.
    virtual void AddVisualizationAssets(VisualizationType vis) override;

    /// Remove visualization assets for the tire subsystem.
    virtual void RemoveVisualizationAssets() override;

    /// Initialize this tire by associating it to the specified wheel.
    virtual void Initialize(std::shared_ptr<ChWheel> wheel) override;

    /// Update the state of this tire system at the current time.
    /// A derived class should also set the current slip, longitudinal slip, and camber angle.
    virtual void Synchronize(double time, const ChTerrain& terrain) override;

    /// Advance the state of this tire by the specified time step.
    virtual void Advance(double step) override;

    /// Get the tire nodes.
    std::vector<std::shared_ptr<fea::ChNodeFEAxyz>>& GetGridNodes() const;

    /// Get the tire rim nodes.
    std::vector<std::shared_ptr<fea::ChNodeFEAxyz>>& GetRimNodes() const;

  protected:
    /// Initialize the tire subsystem inertia properties.
    virtual void InitializeInertiaProperties() override;

    /// Update the tire subsystem inertia properties.
    virtual void UpdateInertiaProperties() override;

  private:
    // Overrides of ChDeformableTire functions
    virtual void CreateContactMaterial() override final;

    // Overrides of ChDeformableTire functions not implemented (used) by ChMBTire
    virtual void CreateMesh(const ChFrameMoving<>& wheel_frame, VehicleSide side) override final {}
    virtual void CreatePressureLoad() override final {}
    virtual void CreateContactSurface() override final {}
    virtual void CreateRimConnections(std::shared_ptr<ChBody> wheel) override final {}
    virtual std::vector<std::shared_ptr<fea::ChNodeFEAbase>> GetConnectedNodes() const final { return {}; }

  private:
    std::shared_ptr<MBTireModel> m_model;
    ChContactMaterialData m_contact_mat_data;
};

// =============================================================================

// Underlying (private) implementation of the MB tire model.
class MBTireModel : public ChPhysicsItem {
  public:
    MBTireModel();

  private:
    // Construct the MB tire relative to the associated wheel/spindle body.
    void Construct(ChTire::ContactSurfaceType surface_type, double surface_dim, int collision_family);

    // Calculate COG and inertia, expressed relative to the frame of the associated wheel/spindle body.
    void CalculateInertiaProperties(ChVector3d& com, ChMatrix33<>& inertia);

    // Set position and velocity of rim nodes from wheel/spindle state.
    void SetRimNodeStates();

    // Calculate nodal forces (expressed in the global frame).
    void CalculateForces();

    // ChPhysicsItem overrides
    virtual bool IsCollisionEnabled() const override { return true; }

    virtual void SyncCollisionModels() override;
    virtual void AddCollisionModelsToSystem(ChCollisionSystem* coll_sys) const override;
    virtual void RemoveCollisionModelsFromSystem(ChCollisionSystem* coll_sys) const override;

    virtual unsigned int GetNumCoordsPosLevel() override { return m_dofs; }
    virtual unsigned int GetNumCoordsVelLevel() override { return m_dofs_w; }
    virtual void SetupInitial() override;
    virtual void Setup() override;
    virtual void Update(double t, bool update_assets = true) override;

    // Add visualization assets for the tire subsystem.
    void AddVisualizationAssets(VisualizationType vis);

    // State functions
    virtual void InjectVariables(ChSystemDescriptor& descriptor) override;
    virtual void InjectKRMMatrices(ChSystemDescriptor& mdescriptor) override;

    virtual void IntStateGather(const unsigned int off_x,
                                ChState& x,
                                const unsigned int off_v,
                                ChStateDelta& v,
                                double& T) override;
    virtual void IntStateScatter(const unsigned int off_x,
                                 const ChState& x,
                                 const unsigned int off_v,
                                 const ChStateDelta& v,
                                 const double T,
                                 bool full_update) override;
    virtual void IntStateGatherAcceleration(const unsigned int off_a, ChStateDelta& a) override;
    virtual void IntStateScatterAcceleration(const unsigned int off_a, const ChStateDelta& a) override;
    virtual void IntStateIncrement(const unsigned int off_x,
                                   ChState& x_new,
                                   const ChState& x,
                                   const unsigned int off_v,
                                   const ChStateDelta& Dv) override;
    virtual void IntStateGetIncrement(const unsigned int off_x,
                                      const ChState& x_new,
                                      const ChState& x,
                                      const unsigned int off_v,
                                      ChStateDelta& Dv) override;
    virtual void IntLoadResidual_F(const unsigned int off, ChVectorDynamic<>& R, const double c) override;
    virtual void IntLoadResidual_Mv(const unsigned int off,
                                    ChVectorDynamic<>& R,
                                    const ChVectorDynamic<>& w,
                                    const double c) override;
    virtual void IntLoadLumpedMass_Md(const unsigned int off,
                                      ChVectorDynamic<>& Md,
                                      double& err,
                                      const double c) override;
    virtual void IntToDescriptor(const unsigned int off_v,
                                 const ChStateDelta& v,
                                 const ChVectorDynamic<>& R,
                                 const unsigned int off_L,
                                 const ChVectorDynamic<>& L,
                                 const ChVectorDynamic<>& Qc) override;
    virtual void IntFromDescriptor(const unsigned int off_v,
                                   ChStateDelta& v,
                                   const unsigned int off_L,
                                   ChVectorDynamic<>& L) override;

    virtual void LoadKRMMatrices(double Kfactor, double Rfactor, double Mfactor) override;

    // Get the node index from the ring index and division index.
    // Return -1 if out-of-bounds ring and use a cyclic index for divisions on the ring.
    int NodeIndex(int ir, int id) const;

    // Get the rim node index from the ring index and division index.
    // Used to identify rim nodes.
    // Return -1 if out-of-bounds ring and use a cyclic index for divisions on the ring.
    int RimNodeIndex(int ir, int id) const;

    // Calculate area of tire surface.
    double CalculateArea() const;

    // Get normal and elemental area for the node with specified ring and division indices.
    void CalculateNormal(int ir, int id, ChVector3d& normal, double& area);

    unsigned int m_dofs;    // total degrees of freedom (position level)
    unsigned int m_dofs_w;  // total degrees of freedom (velocity level)

    int m_num_rings;      // number of rings
    int m_num_divs;       // number of nodes per ring
    int m_num_rim_nodes;  // number of nodes attached to rim
    int m_num_nodes;      // number of nodes and visualization vertices
    int m_num_faces;      // number of visualization triangles

    double m_node_mass;  // nodal mass

    std::vector<double> m_radii;    // ring radii (initial values)
    std::vector<double> m_offsets;  // ring offsets

    double m_rim_radius;  // rim radius

    double m_kR;  // radial elastic coefficient
    double m_cR;  // radial damping coefficient
    double m_kC;  // circumferential elastic coefficient
    double m_cC;  // circumferential damping coefficient
    double m_kT;  // transversal elastic coefficient
    double m_cT;  // transversal damping coefficient
    double m_kB;  // bending elastic coefficient
    double m_cB;  // bending damping coefficient

    std::vector<std::shared_ptr<fea::ChNodeFEAxyz>> m_nodes;      // FEA grid nodes
    std::vector<std::shared_ptr<fea::ChNodeFEAxyz>> m_rim_nodes;  // FEA nodes fixed to the rim
    std::shared_ptr<fea::ChContactSurface> m_contact_surf;        // contact surface
    std::shared_ptr<ChVisualShapeTriangleMesh> m_trimesh_shape;   // mesh visualization asset

    // Base class for all force elements (loads) in an MBTire model.
    // A load can generate forces on 1, 2, or 3 nodes in the system.
    struct Load {
        virtual void CalculateForce() = 0;
        virtual void CalculateJacobian(double Kfactor, double Rfactor) = 0;
        virtual void CalculateJacobianFD(double Kfactor, double Rfactor) = 0;
    };

    // Pressure load acting on a single FEA node.
    struct NodePressure : public Load {
        int inode;  // index of associated node

        fea::ChNodeFEAxyz* node;

        ChBody* wheel;

        double p_times_a;
        ChVector3d force;

        ChKRMBlock KRM;
        ChMatrixDynamic<double> J_fd;

        void Initialize(bool stiff);
        virtual void CalculateForce() override;
        virtual void CalculateJacobian(double Kfactor, double Rfactor) override;
        virtual void CalculateJacobianFD(double Kfactor, double Rfactor) override;

        ChMatrix33<> CalculateJacobianBlock(double Kfactor, double Rfactor);
    };

    // Linear spring between two FEA nodes.
    // Spring forces include both stiffness and damping.
    struct Spring2 : public Load {
        int inode1;  // index of first node
        int inode2;  // index of second node

        fea::ChNodeFEAxyz* node1;
        fea::ChNodeFEAxyz* node2;

        ChBody* wheel;

        double l0;  // spring free length
        double k;   // spring coefficient
        double c;   // damping coefficient

        ChVector3d force1;
        ChVector3d force2;

        ChKRMBlock KRM;
        ChMatrixDynamic<double> J_fd;

        void Initialize();
        virtual void CalculateForce() override;

        ChMatrix33<> CalculateJacobianBlock(double Kfactor, double Rfactor);
    };

    // Rotational spring between three FEA nodes.
    // Spring forces include only stiffness (no velocity-dependence).
    struct Spring3 : public Load {
        int inode_p;  // index of previous node
        int inode_c;  // index of central node
        int inode_n;  // index of next node

        fea::ChNodeFEAxyz* node_p;
        fea::ChNodeFEAxyz* node_c;
        fea::ChNodeFEAxyz* node_n;

        ChBody* wheel;

        ChVector3d t0;  // initial normal direction (in wheel frame)
        double a0;      // spring free angle
        double k;       // spring coefficient
        double c;       // damping coefficient

        ChVector3d force_p;
        ChVector3d force_c;
        ChVector3d force_n;

        ChKRMBlock KRM;
        ChMatrixDynamic<double> J_fd;

        void Initialize();
        virtual void CalculateForce() override;

        ChMatrixNM<double, 6, 9> CalculateJacobianBlockJ1(double Kfactor);
        ChMatrixNM<double, 6, 9> CalculateJacobianBlockJ2(double Kfactor);
    };

    // Linear spring between two grid nodes.
    // F = [ force1 ; force2 ]
    struct GridSpring2 : public Spring2 {
        void Initialize(bool stiff);
        virtual void CalculateJacobian(double Kfactor, double Rfactor) override;
        virtual void CalculateJacobianFD(double Kfactor, double Rfactor) override;
    };

    // Linear spring between a wheel node and a grid node.
    // F = [ force_wheel ; torque_wheel ; force2]
    struct EdgeSpring2 : public Spring2 {
        void Initialize(bool stiff);
        virtual void CalculateForce() override;
        virtual void CalculateJacobian(double Kfactor, double Rfactor) override;
        virtual void CalculateJacobianFD(double Kfactor, double Rfactor) override;

        ChMatrix33<> JacobianRotatedVector();

        ChVector3d local_pos;
        ChVector3d force_wheel;
        ChVector3d torque_wheel;
    };

    // Rotational spring between three grid nodes.
    // F = [ force_p ; force_c ; force_n ]
    struct GridSpring3 : public Spring3 {
        void Initialize(bool stiff);
        virtual void CalculateJacobian(double Kfactor, double Rfactor) override;
        virtual void CalculateJacobianFD(double Kfactor, double Rfactor) override;
    };

    // Rotational spring between a wheel node and two grid nodes.
    // F = [ force_wheel ; torque_wheel ; force_c ; force_n ]
    struct EdgeSpring3 : public Spring3 {
        void Initialize(bool stiff);
        virtual void CalculateForce() override;
        virtual void CalculateJacobian(double Kfactor, double Rfactor) override;
        virtual void CalculateJacobianFD(double Kfactor, double Rfactor) override;

        ChMatrix33<> JacobianRotatedVector();

        ChVector3d local_pos;
        ChVector3d force_wheel;
        ChVector3d torque_wheel;
    };

    std::vector<std::shared_ptr<NodePressure>> m_pressure_loads;   // node pressure loads
    std::vector<std::shared_ptr<GridSpring2>> m_grid_lin_springs;  // node-node translational springs
    std::vector<std::shared_ptr<EdgeSpring2>> m_edge_lin_springs;  // node-rim translational springs
    std::vector<std::shared_ptr<GridSpring3>> m_grid_rot_springs;  // node-node torsional springs
    std::vector<std::shared_ptr<EdgeSpring3>> m_edge_rot_springs;  // node-rim torsional springs

    int m_num_pressure_loads;    // number of node pressure loads
    int m_num_grid_lin_springs;  // number of node-node translational springs
    int m_num_edge_lin_springs;  // number of node-rim translational springs (first and last ring)
    int m_num_grid_rot_springs;  // number of node-node torsional springs
    int m_num_edge_rot_springs;  // number of node-rim torsional springs (first and last ring)

    std::vector<std::shared_ptr<Load>> m_loads;  // all loads in the system
    int m_num_loads;                             // number of all loads in the system

    std::shared_ptr<ChBody> m_wheel;  // associated wheel body
    ChVector3d m_wheel_force;         // applied wheel spindle force (in global frame)
    ChVector3d m_wheel_torque;        // applied wheel spindle torque (in body frame)

    bool m_stiff;      // true if loads are stiff (triggers Jacobian calculation)
    bool m_force_jac;  // force Jacobian calculation (for debugging)

    ChMBTire* m_tire;  // owner ChMBTire object

    friend class ChMBTire;
};

/// @} vehicle_wheeled_tire

}  // end namespace vehicle
}  // end namespace chrono

#endif