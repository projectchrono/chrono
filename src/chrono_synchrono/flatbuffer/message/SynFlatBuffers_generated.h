// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace SynFlatBuffers {
namespace SPAT {

struct State;
struct StateBuilder;

struct Lane;
struct LaneBuilder;

}  // namespace SPAT

struct Vector;
struct VectorBuilder;

struct Quaternion;
struct QuaternionBuilder;

struct Pose;
struct PoseBuilder;

namespace Approach {

struct State;
struct StateBuilder;

struct Lane;
struct LaneBuilder;

}  // namespace Approach

namespace MAP {

struct State;
struct StateBuilder;

struct intersection;
struct intersectionBuilder;

}  // namespace MAP

namespace Agent {
namespace WheeledVehicle {

struct State;
struct StateBuilder;

struct Description;
struct DescriptionBuilder;

}  // namespace WheeledVehicle

namespace TrackedVehicle {

struct State;
struct StateBuilder;

struct Description;
struct DescriptionBuilder;

}  // namespace TrackedVehicle

namespace Copter {

struct State;
struct StateBuilder;

struct Description;
struct DescriptionBuilder;

}  // namespace Copter

namespace Environment {

struct State;
struct StateBuilder;

struct Description;
struct DescriptionBuilder;

}  // namespace Environment

struct State;
struct StateBuilder;

struct Description;
struct DescriptionBuilder;

}  // namespace Agent

namespace Terrain {
namespace SCM {

struct NodeLevel;

struct State;
struct StateBuilder;

}  // namespace SCM

struct State;
struct StateBuilder;

}  // namespace Terrain

namespace Simulation {

struct State;
struct StateBuilder;

}  // namespace Simulation

struct Buffer;
struct BufferBuilder;

struct Message;
struct MessageBuilder;

namespace SPAT {

enum Color : int8_t {
  Color_Green = 0,
  Color_Yellow = 1,
  Color_Red = 2,
  Color_MIN = Color_Green,
  Color_MAX = Color_Red
};

inline const Color (&EnumValuesColor())[3] {
  static const Color values[] = {
    Color_Green,
    Color_Yellow,
    Color_Red
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[4] = {
    "Green",
    "Yellow",
    "Red",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (flatbuffers::IsOutRange(e, Color_Green, Color_Red)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

}  // namespace SPAT

namespace Agent {

enum Type : uint8_t {
  Type_NONE = 0,
  Type_WheeledVehicle_State = 1,
  Type_WheeledVehicle_Description = 2,
  Type_TrackedVehicle_State = 3,
  Type_TrackedVehicle_Description = 4,
  Type_Environment_State = 5,
  Type_Environment_Description = 6,
  Type_Copter_State = 7,
  Type_Copter_Description = 8,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Copter_Description
};

inline const Type (&EnumValuesType())[9] {
  static const Type values[] = {
    Type_NONE,
    Type_WheeledVehicle_State,
    Type_WheeledVehicle_Description,
    Type_TrackedVehicle_State,
    Type_TrackedVehicle_Description,
    Type_Environment_State,
    Type_Environment_Description,
    Type_Copter_State,
    Type_Copter_Description
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[10] = {
    "NONE",
    "WheeledVehicle_State",
    "WheeledVehicle_Description",
    "TrackedVehicle_State",
    "TrackedVehicle_Description",
    "Environment_State",
    "Environment_Description",
    "Copter_State",
    "Copter_Description",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_NONE, Type_Copter_Description)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::WheeledVehicle::State> {
  static const Type enum_value = Type_WheeledVehicle_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::WheeledVehicle::Description> {
  static const Type enum_value = Type_WheeledVehicle_Description;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::TrackedVehicle::State> {
  static const Type enum_value = Type_TrackedVehicle_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::TrackedVehicle::Description> {
  static const Type enum_value = Type_TrackedVehicle_Description;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Environment::State> {
  static const Type enum_value = Type_Environment_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Environment::Description> {
  static const Type enum_value = Type_Environment_Description;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Copter::State> {
  static const Type enum_value = Type_Copter_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Copter::Description> {
  static const Type enum_value = Type_Copter_Description;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Agent

namespace Terrain {

enum Type : uint8_t {
  Type_NONE = 0,
  Type_SCM_State = 1,
  Type_MIN = Type_NONE,
  Type_MAX = Type_SCM_State
};

inline const Type (&EnumValuesType())[2] {
  static const Type values[] = {
    Type_NONE,
    Type_SCM_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[3] = {
    "NONE",
    "SCM_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_NONE, Type_SCM_State)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Terrain::SCM::State> {
  static const Type enum_value = Type_SCM_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Terrain

enum Type : uint8_t {
  Type_NONE = 0,
  Type_Agent_State = 1,
  Type_Agent_Description = 2,
  Type_SPAT_State = 3,
  Type_MAP_State = 4,
  Type_Terrain_State = 5,
  Type_Approach_State = 6,
  Type_Simulation_State = 7,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Simulation_State
};

inline const Type (&EnumValuesType())[8] {
  static const Type values[] = {
    Type_NONE,
    Type_Agent_State,
    Type_Agent_Description,
    Type_SPAT_State,
    Type_MAP_State,
    Type_Terrain_State,
    Type_Approach_State,
    Type_Simulation_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[9] = {
    "NONE",
    "Agent_State",
    "Agent_Description",
    "SPAT_State",
    "MAP_State",
    "Terrain_State",
    "Approach_State",
    "Simulation_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_NONE, Type_Simulation_State)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::State> {
  static const Type enum_value = Type_Agent_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Description> {
  static const Type enum_value = Type_Agent_Description;
};

template<> struct TypeTraits<SynFlatBuffers::SPAT::State> {
  static const Type enum_value = Type_SPAT_State;
};

template<> struct TypeTraits<SynFlatBuffers::MAP::State> {
  static const Type enum_value = Type_MAP_State;
};

template<> struct TypeTraits<SynFlatBuffers::Terrain::State> {
  static const Type enum_value = Type_Terrain_State;
};

template<> struct TypeTraits<SynFlatBuffers::Approach::State> {
  static const Type enum_value = Type_Approach_State;
};

template<> struct TypeTraits<SynFlatBuffers::Simulation::State> {
  static const Type enum_value = Type_Simulation_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

namespace Terrain {
namespace SCM {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) NodeLevel FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  double level_;

 public:
  NodeLevel()
      : x_(0),
        y_(0),
        level_(0) {
  }
  NodeLevel(int32_t _x, int32_t _y, double _level)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        level_(flatbuffers::EndianScalar(_level)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double level() const {
    return flatbuffers::EndianScalar(level_);
  }
};
FLATBUFFERS_STRUCT_END(NodeLevel, 16);

}  // namespace SCM
}  // namespace Terrain

namespace SPAT {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_LANES = 6
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>(*lanes) : 0;
  return SynFlatBuffers::SPAT::CreateState(
      _fbb,
      time,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERSECTION = 4,
    VT_APPROACH = 6,
    VT_LANE = 8,
    VT_COLOR = 10
  };
  int32_t intersection() const {
    return GetField<int32_t>(VT_INTERSECTION, 0);
  }
  int32_t approach() const {
    return GetField<int32_t>(VT_APPROACH, 0);
  }
  int32_t lane() const {
    return GetField<int32_t>(VT_LANE, 0);
  }
  SynFlatBuffers::SPAT::Color color() const {
    return static_cast<SynFlatBuffers::SPAT::Color>(GetField<int8_t>(VT_COLOR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INTERSECTION) &&
           VerifyField<int32_t>(verifier, VT_APPROACH) &&
           VerifyField<int32_t>(verifier, VT_LANE) &&
           VerifyField<int8_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  typedef Lane Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_intersection(int32_t intersection) {
    fbb_.AddElement<int32_t>(Lane::VT_INTERSECTION, intersection, 0);
  }
  void add_approach(int32_t approach) {
    fbb_.AddElement<int32_t>(Lane::VT_APPROACH, approach, 0);
  }
  void add_lane(int32_t lane) {
    fbb_.AddElement<int32_t>(Lane::VT_LANE, lane, 0);
  }
  void add_color(SynFlatBuffers::SPAT::Color color) {
    fbb_.AddElement<int8_t>(Lane::VT_COLOR, static_cast<int8_t>(color), 0);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t intersection = 0,
    int32_t approach = 0,
    int32_t lane = 0,
    SynFlatBuffers::SPAT::Color color = SynFlatBuffers::SPAT::Color_Green) {
  LaneBuilder builder_(_fbb);
  builder_.add_lane(lane);
  builder_.add_approach(approach);
  builder_.add_intersection(intersection);
  builder_.add_color(color);
  return builder_.Finish();
}

}  // namespace SPAT

struct Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  typedef Vector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector::VT_Z, z, 0.0);
  }
  explicit VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector> CreateVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  VectorBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuaternionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_E0 = 4,
    VT_E1 = 6,
    VT_E2 = 8,
    VT_E3 = 10
  };
  double e0() const {
    return GetField<double>(VT_E0, 0.0);
  }
  double e1() const {
    return GetField<double>(VT_E1, 0.0);
  }
  double e2() const {
    return GetField<double>(VT_E2, 0.0);
  }
  double e3() const {
    return GetField<double>(VT_E3, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_E0) &&
           VerifyField<double>(verifier, VT_E1) &&
           VerifyField<double>(verifier, VT_E2) &&
           VerifyField<double>(verifier, VT_E3) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_e0(double e0) {
    fbb_.AddElement<double>(Quaternion::VT_E0, e0, 0.0);
  }
  void add_e1(double e1) {
    fbb_.AddElement<double>(Quaternion::VT_E1, e1, 0.0);
  }
  void add_e2(double e2) {
    fbb_.AddElement<double>(Quaternion::VT_E2, e2, 0.0);
  }
  void add_e3(double e3) {
    fbb_.AddElement<double>(Quaternion::VT_E3, e3, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    double e0 = 0.0,
    double e1 = 0.0,
    double e2 = 0.0,
    double e3 = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_e3(e3);
  builder_.add_e2(e2);
  builder_.add_e1(e1);
  builder_.add_e0(e0);
  return builder_.Finish();
}

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ROT = 6,
    VT_POS_DT = 8,
    VT_ROT_DT = 10,
    VT_POS_DTDT = 12,
    VT_ROT_DTDT = 14
  };
  const SynFlatBuffers::Vector *pos() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_POS);
  }
  const SynFlatBuffers::Quaternion *rot() const {
    return GetPointer<const SynFlatBuffers::Quaternion *>(VT_ROT);
  }
  const SynFlatBuffers::Vector *pos_dt() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_POS_DT);
  }
  const SynFlatBuffers::Quaternion *rot_dt() const {
    return GetPointer<const SynFlatBuffers::Quaternion *>(VT_ROT_DT);
  }
  const SynFlatBuffers::Vector *pos_dtdt() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_POS_DTDT);
  }
  const SynFlatBuffers::Quaternion *rot_dtdt() const {
    return GetPointer<const SynFlatBuffers::Quaternion *>(VT_ROT_DTDT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffset(verifier, VT_ROT) &&
           verifier.VerifyTable(rot()) &&
           VerifyOffset(verifier, VT_POS_DT) &&
           verifier.VerifyTable(pos_dt()) &&
           VerifyOffset(verifier, VT_ROT_DT) &&
           verifier.VerifyTable(rot_dt()) &&
           VerifyOffset(verifier, VT_POS_DTDT) &&
           verifier.VerifyTable(pos_dtdt()) &&
           VerifyOffset(verifier, VT_ROT_DTDT) &&
           verifier.VerifyTable(rot_dtdt()) &&
           verifier.EndTable();
  }
};

struct PoseBuilder {
  typedef Pose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<SynFlatBuffers::Vector> pos) {
    fbb_.AddOffset(Pose::VT_POS, pos);
  }
  void add_rot(flatbuffers::Offset<SynFlatBuffers::Quaternion> rot) {
    fbb_.AddOffset(Pose::VT_ROT, rot);
  }
  void add_pos_dt(flatbuffers::Offset<SynFlatBuffers::Vector> pos_dt) {
    fbb_.AddOffset(Pose::VT_POS_DT, pos_dt);
  }
  void add_rot_dt(flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dt) {
    fbb_.AddOffset(Pose::VT_ROT_DT, rot_dt);
  }
  void add_pos_dtdt(flatbuffers::Offset<SynFlatBuffers::Vector> pos_dtdt) {
    fbb_.AddOffset(Pose::VT_POS_DTDT, pos_dtdt);
  }
  void add_rot_dtdt(flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dtdt) {
    fbb_.AddOffset(Pose::VT_ROT_DTDT, rot_dtdt);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::Vector> pos = 0,
    flatbuffers::Offset<SynFlatBuffers::Quaternion> rot = 0,
    flatbuffers::Offset<SynFlatBuffers::Vector> pos_dt = 0,
    flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dt = 0,
    flatbuffers::Offset<SynFlatBuffers::Vector> pos_dtdt = 0,
    flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dtdt = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_rot_dtdt(rot_dtdt);
  builder_.add_pos_dtdt(pos_dtdt);
  builder_.add_rot_dt(rot_dt);
  builder_.add_pos_dt(pos_dt);
  builder_.add_rot(rot);
  builder_.add_pos(pos);
  return builder_.Finish();
}

namespace Approach {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_LANES = 6
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>>(*lanes) : 0;
  return SynFlatBuffers::Approach::CreateState(
      _fbb,
      time,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_CONTROLPOINTS = 6
  };
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>> *controlPoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>> *>(VT_CONTROLPOINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_CONTROLPOINTS) &&
           verifier.VerifyVector(controlPoints()) &&
           verifier.VerifyVectorOfTables(controlPoints()) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  typedef Lane Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(double width) {
    fbb_.AddElement<double>(Lane::VT_WIDTH, width, 0.0);
  }
  void add_controlPoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>>> controlPoints) {
    fbb_.AddOffset(Lane::VT_CONTROLPOINTS, controlPoints);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    double width = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>>> controlPoints = 0) {
  LaneBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_controlPoints(controlPoints);
  return builder_.Finish();
}

inline flatbuffers::Offset<Lane> CreateLaneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double width = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Vector>> *controlPoints = nullptr) {
  auto controlPoints__ = controlPoints ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Vector>>(*controlPoints) : 0;
  return SynFlatBuffers::Approach::CreateLane(
      _fbb,
      width,
      controlPoints__);
}

}  // namespace Approach

namespace MAP {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_INTERSECTIONS = 6
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>> *intersections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>> *>(VT_INTERSECTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_INTERSECTIONS) &&
           verifier.VerifyVector(intersections()) &&
           verifier.VerifyVectorOfTables(intersections()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_intersections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>>> intersections) {
    fbb_.AddOffset(State::VT_INTERSECTIONS, intersections);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>>> intersections = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_intersections(intersections);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>> *intersections = nullptr) {
  auto intersections__ = intersections ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>>(*intersections) : 0;
  return SynFlatBuffers::MAP::CreateState(
      _fbb,
      time,
      intersections__);
}

struct intersection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef intersectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROACHES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>> *approaches() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>> *>(VT_APPROACHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APPROACHES) &&
           verifier.VerifyVector(approaches()) &&
           verifier.VerifyVectorOfTables(approaches()) &&
           verifier.EndTable();
  }
};

struct intersectionBuilder {
  typedef intersection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_approaches(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>>> approaches) {
    fbb_.AddOffset(intersection::VT_APPROACHES, approaches);
  }
  explicit intersectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<intersection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<intersection>(end);
    return o;
  }
};

inline flatbuffers::Offset<intersection> Createintersection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>>> approaches = 0) {
  intersectionBuilder builder_(_fbb);
  builder_.add_approaches(approaches);
  return builder_.Finish();
}

inline flatbuffers::Offset<intersection> CreateintersectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>> *approaches = nullptr) {
  auto approaches__ = approaches ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Approach::State>>(*approaches) : 0;
  return SynFlatBuffers::MAP::Createintersection(
      _fbb,
      approaches__);
}

}  // namespace MAP

namespace Agent {
namespace WheeledVehicle {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_WHEELS = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::Pose *chassis() const {
    return GetPointer<const SynFlatBuffers::Pose *>(VT_CHASSIS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *wheels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_WHEELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_WHEELS) &&
           verifier.VerifyVector(wheels()) &&
           verifier.VerifyVectorOfTables(wheels()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<SynFlatBuffers::Pose> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_wheels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> wheels) {
    fbb_.AddOffset(State::VT_WHEELS, wheels);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> wheels = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_wheels(wheels);
  builder_.add_chassis(chassis);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *wheels = nullptr) {
  auto wheels__ = wheels ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*wheels) : 0;
  return SynFlatBuffers::Agent::WheeledVehicle::CreateState(
      _fbb,
      time,
      chassis,
      wheels__);
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DescriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHASSIS_VIS_FILE = 4,
    VT_WHEEL_VIS_FILE = 6,
    VT_TIRE_VIS_FILE = 8,
    VT_NUM_WHEELS = 10
  };
  const flatbuffers::String *chassis_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_CHASSIS_VIS_FILE);
  }
  const flatbuffers::String *wheel_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_WHEEL_VIS_FILE);
  }
  const flatbuffers::String *tire_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_TIRE_VIS_FILE);
  }
  int32_t num_wheels() const {
    return GetField<int32_t>(VT_NUM_WHEELS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHASSIS_VIS_FILE) &&
           verifier.VerifyString(chassis_vis_file()) &&
           VerifyOffset(verifier, VT_WHEEL_VIS_FILE) &&
           verifier.VerifyString(wheel_vis_file()) &&
           VerifyOffset(verifier, VT_TIRE_VIS_FILE) &&
           verifier.VerifyString(tire_vis_file()) &&
           VerifyField<int32_t>(verifier, VT_NUM_WHEELS) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  typedef Description Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chassis_vis_file(flatbuffers::Offset<flatbuffers::String> chassis_vis_file) {
    fbb_.AddOffset(Description::VT_CHASSIS_VIS_FILE, chassis_vis_file);
  }
  void add_wheel_vis_file(flatbuffers::Offset<flatbuffers::String> wheel_vis_file) {
    fbb_.AddOffset(Description::VT_WHEEL_VIS_FILE, wheel_vis_file);
  }
  void add_tire_vis_file(flatbuffers::Offset<flatbuffers::String> tire_vis_file) {
    fbb_.AddOffset(Description::VT_TIRE_VIS_FILE, tire_vis_file);
  }
  void add_num_wheels(int32_t num_wheels) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_WHEELS, num_wheels, 0);
  }
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> chassis_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> wheel_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> tire_vis_file = 0,
    int32_t num_wheels = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_num_wheels(num_wheels);
  builder_.add_tire_vis_file(tire_vis_file);
  builder_.add_wheel_vis_file(wheel_vis_file);
  builder_.add_chassis_vis_file(chassis_vis_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Description> CreateDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *chassis_vis_file = nullptr,
    const char *wheel_vis_file = nullptr,
    const char *tire_vis_file = nullptr,
    int32_t num_wheels = 0) {
  auto chassis_vis_file__ = chassis_vis_file ? _fbb.CreateString(chassis_vis_file) : 0;
  auto wheel_vis_file__ = wheel_vis_file ? _fbb.CreateString(wheel_vis_file) : 0;
  auto tire_vis_file__ = tire_vis_file ? _fbb.CreateString(tire_vis_file) : 0;
  return SynFlatBuffers::Agent::WheeledVehicle::CreateDescription(
      _fbb,
      chassis_vis_file__,
      wheel_vis_file__,
      tire_vis_file__,
      num_wheels);
}

}  // namespace WheeledVehicle

namespace TrackedVehicle {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_TRACK_SHOES = 8,
    VT_SPROCKETS = 10,
    VT_IDLERS = 12,
    VT_ROAD_WHEELS = 14
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::Pose *chassis() const {
    return GetPointer<const SynFlatBuffers::Pose *>(VT_CHASSIS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *track_shoes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_TRACK_SHOES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *sprockets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_SPROCKETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *idlers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_IDLERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *road_wheels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_ROAD_WHEELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_TRACK_SHOES) &&
           verifier.VerifyVector(track_shoes()) &&
           verifier.VerifyVectorOfTables(track_shoes()) &&
           VerifyOffset(verifier, VT_SPROCKETS) &&
           verifier.VerifyVector(sprockets()) &&
           verifier.VerifyVectorOfTables(sprockets()) &&
           VerifyOffset(verifier, VT_IDLERS) &&
           verifier.VerifyVector(idlers()) &&
           verifier.VerifyVectorOfTables(idlers()) &&
           VerifyOffset(verifier, VT_ROAD_WHEELS) &&
           verifier.VerifyVector(road_wheels()) &&
           verifier.VerifyVectorOfTables(road_wheels()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<SynFlatBuffers::Pose> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_track_shoes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> track_shoes) {
    fbb_.AddOffset(State::VT_TRACK_SHOES, track_shoes);
  }
  void add_sprockets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> sprockets) {
    fbb_.AddOffset(State::VT_SPROCKETS, sprockets);
  }
  void add_idlers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> idlers) {
    fbb_.AddOffset(State::VT_IDLERS, idlers);
  }
  void add_road_wheels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> road_wheels) {
    fbb_.AddOffset(State::VT_ROAD_WHEELS, road_wheels);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> track_shoes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> sprockets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> idlers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> road_wheels = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_road_wheels(road_wheels);
  builder_.add_idlers(idlers);
  builder_.add_sprockets(sprockets);
  builder_.add_track_shoes(track_shoes);
  builder_.add_chassis(chassis);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *track_shoes = nullptr,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *sprockets = nullptr,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *idlers = nullptr,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *road_wheels = nullptr) {
  auto track_shoes__ = track_shoes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*track_shoes) : 0;
  auto sprockets__ = sprockets ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*sprockets) : 0;
  auto idlers__ = idlers ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*idlers) : 0;
  auto road_wheels__ = road_wheels ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*road_wheels) : 0;
  return SynFlatBuffers::Agent::TrackedVehicle::CreateState(
      _fbb,
      time,
      chassis,
      track_shoes__,
      sprockets__,
      idlers__,
      road_wheels__);
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DescriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHASSIS_VIS_FILE = 4,
    VT_TRACK_SHOE_VIS_FILE = 6,
    VT_LEFT_SPROCKET_VIS_FILE = 8,
    VT_RIGHT_SPROCKET_VIS_FILE = 10,
    VT_LEFT_IDLER_VIS_FILE = 12,
    VT_RIGHT_IDLER_VIS_FILE = 14,
    VT_LEFT_ROAD_WHEEL_VIS_FILE = 16,
    VT_RIGHT_ROAD_WHEEL_VIS_FILE = 18,
    VT_NUM_TRACK_SHOES = 20,
    VT_NUM_SPROCKETS = 22,
    VT_NUM_IDLERS = 24,
    VT_NUM_ROAD_WHEELS = 26
  };
  const flatbuffers::String *chassis_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_CHASSIS_VIS_FILE);
  }
  const flatbuffers::String *track_shoe_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_TRACK_SHOE_VIS_FILE);
  }
  const flatbuffers::String *left_sprocket_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_LEFT_SPROCKET_VIS_FILE);
  }
  const flatbuffers::String *right_sprocket_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_RIGHT_SPROCKET_VIS_FILE);
  }
  const flatbuffers::String *left_idler_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_LEFT_IDLER_VIS_FILE);
  }
  const flatbuffers::String *right_idler_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_RIGHT_IDLER_VIS_FILE);
  }
  const flatbuffers::String *left_road_wheel_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_LEFT_ROAD_WHEEL_VIS_FILE);
  }
  const flatbuffers::String *right_road_wheel_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_RIGHT_ROAD_WHEEL_VIS_FILE);
  }
  int32_t num_track_shoes() const {
    return GetField<int32_t>(VT_NUM_TRACK_SHOES, 0);
  }
  int32_t num_sprockets() const {
    return GetField<int32_t>(VT_NUM_SPROCKETS, 0);
  }
  int32_t num_idlers() const {
    return GetField<int32_t>(VT_NUM_IDLERS, 0);
  }
  int32_t num_road_wheels() const {
    return GetField<int32_t>(VT_NUM_ROAD_WHEELS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHASSIS_VIS_FILE) &&
           verifier.VerifyString(chassis_vis_file()) &&
           VerifyOffset(verifier, VT_TRACK_SHOE_VIS_FILE) &&
           verifier.VerifyString(track_shoe_vis_file()) &&
           VerifyOffset(verifier, VT_LEFT_SPROCKET_VIS_FILE) &&
           verifier.VerifyString(left_sprocket_vis_file()) &&
           VerifyOffset(verifier, VT_RIGHT_SPROCKET_VIS_FILE) &&
           verifier.VerifyString(right_sprocket_vis_file()) &&
           VerifyOffset(verifier, VT_LEFT_IDLER_VIS_FILE) &&
           verifier.VerifyString(left_idler_vis_file()) &&
           VerifyOffset(verifier, VT_RIGHT_IDLER_VIS_FILE) &&
           verifier.VerifyString(right_idler_vis_file()) &&
           VerifyOffset(verifier, VT_LEFT_ROAD_WHEEL_VIS_FILE) &&
           verifier.VerifyString(left_road_wheel_vis_file()) &&
           VerifyOffset(verifier, VT_RIGHT_ROAD_WHEEL_VIS_FILE) &&
           verifier.VerifyString(right_road_wheel_vis_file()) &&
           VerifyField<int32_t>(verifier, VT_NUM_TRACK_SHOES) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPROCKETS) &&
           VerifyField<int32_t>(verifier, VT_NUM_IDLERS) &&
           VerifyField<int32_t>(verifier, VT_NUM_ROAD_WHEELS) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  typedef Description Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chassis_vis_file(flatbuffers::Offset<flatbuffers::String> chassis_vis_file) {
    fbb_.AddOffset(Description::VT_CHASSIS_VIS_FILE, chassis_vis_file);
  }
  void add_track_shoe_vis_file(flatbuffers::Offset<flatbuffers::String> track_shoe_vis_file) {
    fbb_.AddOffset(Description::VT_TRACK_SHOE_VIS_FILE, track_shoe_vis_file);
  }
  void add_left_sprocket_vis_file(flatbuffers::Offset<flatbuffers::String> left_sprocket_vis_file) {
    fbb_.AddOffset(Description::VT_LEFT_SPROCKET_VIS_FILE, left_sprocket_vis_file);
  }
  void add_right_sprocket_vis_file(flatbuffers::Offset<flatbuffers::String> right_sprocket_vis_file) {
    fbb_.AddOffset(Description::VT_RIGHT_SPROCKET_VIS_FILE, right_sprocket_vis_file);
  }
  void add_left_idler_vis_file(flatbuffers::Offset<flatbuffers::String> left_idler_vis_file) {
    fbb_.AddOffset(Description::VT_LEFT_IDLER_VIS_FILE, left_idler_vis_file);
  }
  void add_right_idler_vis_file(flatbuffers::Offset<flatbuffers::String> right_idler_vis_file) {
    fbb_.AddOffset(Description::VT_RIGHT_IDLER_VIS_FILE, right_idler_vis_file);
  }
  void add_left_road_wheel_vis_file(flatbuffers::Offset<flatbuffers::String> left_road_wheel_vis_file) {
    fbb_.AddOffset(Description::VT_LEFT_ROAD_WHEEL_VIS_FILE, left_road_wheel_vis_file);
  }
  void add_right_road_wheel_vis_file(flatbuffers::Offset<flatbuffers::String> right_road_wheel_vis_file) {
    fbb_.AddOffset(Description::VT_RIGHT_ROAD_WHEEL_VIS_FILE, right_road_wheel_vis_file);
  }
  void add_num_track_shoes(int32_t num_track_shoes) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_TRACK_SHOES, num_track_shoes, 0);
  }
  void add_num_sprockets(int32_t num_sprockets) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_SPROCKETS, num_sprockets, 0);
  }
  void add_num_idlers(int32_t num_idlers) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_IDLERS, num_idlers, 0);
  }
  void add_num_road_wheels(int32_t num_road_wheels) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_ROAD_WHEELS, num_road_wheels, 0);
  }
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> chassis_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> track_shoe_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> left_sprocket_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> right_sprocket_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> left_idler_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> right_idler_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> left_road_wheel_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> right_road_wheel_vis_file = 0,
    int32_t num_track_shoes = 0,
    int32_t num_sprockets = 0,
    int32_t num_idlers = 0,
    int32_t num_road_wheels = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_num_road_wheels(num_road_wheels);
  builder_.add_num_idlers(num_idlers);
  builder_.add_num_sprockets(num_sprockets);
  builder_.add_num_track_shoes(num_track_shoes);
  builder_.add_right_road_wheel_vis_file(right_road_wheel_vis_file);
  builder_.add_left_road_wheel_vis_file(left_road_wheel_vis_file);
  builder_.add_right_idler_vis_file(right_idler_vis_file);
  builder_.add_left_idler_vis_file(left_idler_vis_file);
  builder_.add_right_sprocket_vis_file(right_sprocket_vis_file);
  builder_.add_left_sprocket_vis_file(left_sprocket_vis_file);
  builder_.add_track_shoe_vis_file(track_shoe_vis_file);
  builder_.add_chassis_vis_file(chassis_vis_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Description> CreateDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *chassis_vis_file = nullptr,
    const char *track_shoe_vis_file = nullptr,
    const char *left_sprocket_vis_file = nullptr,
    const char *right_sprocket_vis_file = nullptr,
    const char *left_idler_vis_file = nullptr,
    const char *right_idler_vis_file = nullptr,
    const char *left_road_wheel_vis_file = nullptr,
    const char *right_road_wheel_vis_file = nullptr,
    int32_t num_track_shoes = 0,
    int32_t num_sprockets = 0,
    int32_t num_idlers = 0,
    int32_t num_road_wheels = 0) {
  auto chassis_vis_file__ = chassis_vis_file ? _fbb.CreateString(chassis_vis_file) : 0;
  auto track_shoe_vis_file__ = track_shoe_vis_file ? _fbb.CreateString(track_shoe_vis_file) : 0;
  auto left_sprocket_vis_file__ = left_sprocket_vis_file ? _fbb.CreateString(left_sprocket_vis_file) : 0;
  auto right_sprocket_vis_file__ = right_sprocket_vis_file ? _fbb.CreateString(right_sprocket_vis_file) : 0;
  auto left_idler_vis_file__ = left_idler_vis_file ? _fbb.CreateString(left_idler_vis_file) : 0;
  auto right_idler_vis_file__ = right_idler_vis_file ? _fbb.CreateString(right_idler_vis_file) : 0;
  auto left_road_wheel_vis_file__ = left_road_wheel_vis_file ? _fbb.CreateString(left_road_wheel_vis_file) : 0;
  auto right_road_wheel_vis_file__ = right_road_wheel_vis_file ? _fbb.CreateString(right_road_wheel_vis_file) : 0;
  return SynFlatBuffers::Agent::TrackedVehicle::CreateDescription(
      _fbb,
      chassis_vis_file__,
      track_shoe_vis_file__,
      left_sprocket_vis_file__,
      right_sprocket_vis_file__,
      left_idler_vis_file__,
      right_idler_vis_file__,
      left_road_wheel_vis_file__,
      right_road_wheel_vis_file__,
      num_track_shoes,
      num_sprockets,
      num_idlers,
      num_road_wheels);
}

}  // namespace TrackedVehicle

namespace Copter {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_PROPELLERS = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::Pose *chassis() const {
    return GetPointer<const SynFlatBuffers::Pose *>(VT_CHASSIS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *propellers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_PROPELLERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_PROPELLERS) &&
           verifier.VerifyVector(propellers()) &&
           verifier.VerifyVectorOfTables(propellers()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<SynFlatBuffers::Pose> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_propellers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> propellers) {
    fbb_.AddOffset(State::VT_PROPELLERS, propellers);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> propellers = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_propellers(propellers);
  builder_.add_chassis(chassis);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *propellers = nullptr) {
  auto propellers__ = propellers ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*propellers) : 0;
  return SynFlatBuffers::Agent::Copter::CreateState(
      _fbb,
      time,
      chassis,
      propellers__);
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DescriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHASSIS_VIS_FILE = 4,
    VT_PROPELLER_VIS_FILE = 6,
    VT_NUM_PROPS = 8
  };
  const flatbuffers::String *chassis_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_CHASSIS_VIS_FILE);
  }
  const flatbuffers::String *propeller_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_PROPELLER_VIS_FILE);
  }
  int32_t num_props() const {
    return GetField<int32_t>(VT_NUM_PROPS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHASSIS_VIS_FILE) &&
           verifier.VerifyString(chassis_vis_file()) &&
           VerifyOffset(verifier, VT_PROPELLER_VIS_FILE) &&
           verifier.VerifyString(propeller_vis_file()) &&
           VerifyField<int32_t>(verifier, VT_NUM_PROPS) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  typedef Description Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chassis_vis_file(flatbuffers::Offset<flatbuffers::String> chassis_vis_file) {
    fbb_.AddOffset(Description::VT_CHASSIS_VIS_FILE, chassis_vis_file);
  }
  void add_propeller_vis_file(flatbuffers::Offset<flatbuffers::String> propeller_vis_file) {
    fbb_.AddOffset(Description::VT_PROPELLER_VIS_FILE, propeller_vis_file);
  }
  void add_num_props(int32_t num_props) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_PROPS, num_props, 0);
  }
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> chassis_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> propeller_vis_file = 0,
    int32_t num_props = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_num_props(num_props);
  builder_.add_propeller_vis_file(propeller_vis_file);
  builder_.add_chassis_vis_file(chassis_vis_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Description> CreateDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *chassis_vis_file = nullptr,
    const char *propeller_vis_file = nullptr,
    int32_t num_props = 0) {
  auto chassis_vis_file__ = chassis_vis_file ? _fbb.CreateString(chassis_vis_file) : 0;
  auto propeller_vis_file__ = propeller_vis_file ? _fbb.CreateString(propeller_vis_file) : 0;
  return SynFlatBuffers::Agent::Copter::CreateDescription(
      _fbb,
      chassis_vis_file__,
      propeller_vis_file__,
      num_props);
}

}  // namespace Copter

namespace Environment {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP = 4,
    VT_SPAT = 6
  };
  const SynFlatBuffers::Message *map() const {
    return GetPointer<const SynFlatBuffers::Message *>(VT_MAP);
  }
  const SynFlatBuffers::Message *spat() const {
    return GetPointer<const SynFlatBuffers::Message *>(VT_SPAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyOffset(verifier, VT_SPAT) &&
           verifier.VerifyTable(spat()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map(flatbuffers::Offset<SynFlatBuffers::Message> map) {
    fbb_.AddOffset(State::VT_MAP, map);
  }
  void add_spat(flatbuffers::Offset<SynFlatBuffers::Message> spat) {
    fbb_.AddOffset(State::VT_SPAT, spat);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::Message> map = 0,
    flatbuffers::Offset<SynFlatBuffers::Message> spat = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_spat(spat);
  builder_.add_map(map);
  return builder_.Finish();
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DescriptionBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  typedef Description Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DescriptionBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace Environment

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  SynFlatBuffers::Agent::Type message_type() const {
    return static_cast<SynFlatBuffers::Agent::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Agent::WheeledVehicle::State *message_as_WheeledVehicle_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_State ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::WheeledVehicle::Description *message_as_WheeledVehicle_Description() const {
    return message_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_Description ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::Description *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::State *message_as_TrackedVehicle_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_State ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::Description *message_as_TrackedVehicle_Description() const {
    return message_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_Description ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::Description *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::State *message_as_Environment_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_Environment_State ? static_cast<const SynFlatBuffers::Agent::Environment::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::Description *message_as_Environment_Description() const {
    return message_type() == SynFlatBuffers::Agent::Type_Environment_Description ? static_cast<const SynFlatBuffers::Agent::Environment::Description *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Copter::State *message_as_Copter_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_Copter_State ? static_cast<const SynFlatBuffers::Agent::Copter::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Copter::Description *message_as_Copter_Description() const {
    return message_type() == SynFlatBuffers::Agent::Type_Copter_Description ? static_cast<const SynFlatBuffers::Agent::Copter::Description *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::State *State::message_as<SynFlatBuffers::Agent::WheeledVehicle::State>() const {
  return message_as_WheeledVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::Description *State::message_as<SynFlatBuffers::Agent::WheeledVehicle::Description>() const {
  return message_as_WheeledVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::State *State::message_as<SynFlatBuffers::Agent::TrackedVehicle::State>() const {
  return message_as_TrackedVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::Description *State::message_as<SynFlatBuffers::Agent::TrackedVehicle::Description>() const {
  return message_as_TrackedVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::Environment::State *State::message_as<SynFlatBuffers::Agent::Environment::State>() const {
  return message_as_Environment_State();
}

template<> inline const SynFlatBuffers::Agent::Environment::Description *State::message_as<SynFlatBuffers::Agent::Environment::Description>() const {
  return message_as_Environment_Description();
}

template<> inline const SynFlatBuffers::Agent::Copter::State *State::message_as<SynFlatBuffers::Agent::Copter::State>() const {
  return message_as_Copter_State();
}

template<> inline const SynFlatBuffers::Agent::Copter::Description *State::message_as<SynFlatBuffers::Agent::Copter::Description>() const {
  return message_as_Copter_Description();
}

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Agent::Type message_type) {
    fbb_.AddElement<uint8_t>(State::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(State::VT_MESSAGE, message);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type message_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> message = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DescriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESCRIPTION_TYPE = 4,
    VT_DESCRIPTION = 6,
    VT_JSON = 8
  };
  SynFlatBuffers::Agent::Type description_type() const {
    return static_cast<SynFlatBuffers::Agent::Type>(GetField<uint8_t>(VT_DESCRIPTION_TYPE, 0));
  }
  const void *description() const {
    return GetPointer<const void *>(VT_DESCRIPTION);
  }
  template<typename T> const T *description_as() const;
  const SynFlatBuffers::Agent::WheeledVehicle::State *description_as_WheeledVehicle_State() const {
    return description_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_State ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::State *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::WheeledVehicle::Description *description_as_WheeledVehicle_Description() const {
    return description_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_Description ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::Description *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::State *description_as_TrackedVehicle_State() const {
    return description_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_State ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::State *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::Description *description_as_TrackedVehicle_Description() const {
    return description_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_Description ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::Description *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::State *description_as_Environment_State() const {
    return description_type() == SynFlatBuffers::Agent::Type_Environment_State ? static_cast<const SynFlatBuffers::Agent::Environment::State *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::Description *description_as_Environment_Description() const {
    return description_type() == SynFlatBuffers::Agent::Type_Environment_Description ? static_cast<const SynFlatBuffers::Agent::Environment::Description *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::Copter::State *description_as_Copter_State() const {
    return description_type() == SynFlatBuffers::Agent::Type_Copter_State ? static_cast<const SynFlatBuffers::Agent::Copter::State *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::Copter::Description *description_as_Copter_Description() const {
    return description_type() == SynFlatBuffers::Agent::Type_Copter_Description ? static_cast<const SynFlatBuffers::Agent::Copter::Description *>(description()) : nullptr;
  }
  const flatbuffers::String *json() const {
    return GetPointer<const flatbuffers::String *>(VT_JSON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DESCRIPTION_TYPE) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           VerifyType(verifier, description(), description_type()) &&
           VerifyOffset(verifier, VT_JSON) &&
           verifier.VerifyString(json()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::State *Description::description_as<SynFlatBuffers::Agent::WheeledVehicle::State>() const {
  return description_as_WheeledVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::Description *Description::description_as<SynFlatBuffers::Agent::WheeledVehicle::Description>() const {
  return description_as_WheeledVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::State *Description::description_as<SynFlatBuffers::Agent::TrackedVehicle::State>() const {
  return description_as_TrackedVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::Description *Description::description_as<SynFlatBuffers::Agent::TrackedVehicle::Description>() const {
  return description_as_TrackedVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::Environment::State *Description::description_as<SynFlatBuffers::Agent::Environment::State>() const {
  return description_as_Environment_State();
}

template<> inline const SynFlatBuffers::Agent::Environment::Description *Description::description_as<SynFlatBuffers::Agent::Environment::Description>() const {
  return description_as_Environment_Description();
}

template<> inline const SynFlatBuffers::Agent::Copter::State *Description::description_as<SynFlatBuffers::Agent::Copter::State>() const {
  return description_as_Copter_State();
}

template<> inline const SynFlatBuffers::Agent::Copter::Description *Description::description_as<SynFlatBuffers::Agent::Copter::Description>() const {
  return description_as_Copter_Description();
}

struct DescriptionBuilder {
  typedef Description Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_description_type(SynFlatBuffers::Agent::Type description_type) {
    fbb_.AddElement<uint8_t>(Description::VT_DESCRIPTION_TYPE, static_cast<uint8_t>(description_type), 0);
  }
  void add_description(flatbuffers::Offset<void> description) {
    fbb_.AddOffset(Description::VT_DESCRIPTION, description);
  }
  void add_json(flatbuffers::Offset<flatbuffers::String> json) {
    fbb_.AddOffset(Description::VT_JSON, json);
  }
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type description_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> description = 0,
    flatbuffers::Offset<flatbuffers::String> json = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_json(json);
  builder_.add_description(description);
  builder_.add_description_type(description_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Description> CreateDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type description_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> description = 0,
    const char *json = nullptr) {
  auto json__ = json ? _fbb.CreateString(json) : 0;
  return SynFlatBuffers::Agent::CreateDescription(
      _fbb,
      description_type,
      description,
      json__);
}

}  // namespace Agent

namespace Terrain {
namespace SCM {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_NODES = 6
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *> *nodes() const {
    return GetPointer<const flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *>> nodes) {
    fbb_.AddOffset(State::VT_NODES, nodes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *>> nodes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    const std::vector<SynFlatBuffers::Terrain::SCM::NodeLevel> *nodes = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVectorOfStructs<SynFlatBuffers::Terrain::SCM::NodeLevel>(*nodes) : 0;
  return SynFlatBuffers::Terrain::SCM::CreateState(
      _fbb,
      time,
      nodes__);
}

}  // namespace SCM

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  SynFlatBuffers::Terrain::Type message_type() const {
    return static_cast<SynFlatBuffers::Terrain::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Terrain::SCM::State *message_as_SCM_State() const {
    return message_type() == SynFlatBuffers::Terrain::Type_SCM_State ? static_cast<const SynFlatBuffers::Terrain::SCM::State *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Terrain::SCM::State *State::message_as<SynFlatBuffers::Terrain::SCM::State>() const {
  return message_as_SCM_State();
}

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Terrain::Type message_type) {
    fbb_.AddElement<uint8_t>(State::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(State::VT_MESSAGE, message);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Terrain::Type message_type = SynFlatBuffers::Terrain::Type_NONE,
    flatbuffers::Offset<void> message = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

}  // namespace Terrain

namespace Simulation {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUIT_SIM = 4
  };
  bool quit_sim() const {
    return GetField<uint8_t>(VT_QUIT_SIM, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_QUIT_SIM) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  typedef State Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_quit_sim(bool quit_sim) {
    fbb_.AddElement<uint8_t>(State::VT_QUIT_SIM, static_cast<uint8_t>(quit_sim), 0);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool quit_sim = false) {
  StateBuilder builder_(_fbb);
  builder_.add_quit_sim(quit_sim);
  return builder_.Finish();
}

}  // namespace Simulation

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.VerifyVectorOfTables(buffer()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  typedef Buffer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer) {
    fbb_.AddOffset(Buffer::VT_BUFFER, buffer);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Message>>(*buffer) : 0;
  return SynFlatBuffers::CreateBuffer(
      _fbb,
      buffer__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_SOURCE_ID = 8,
    VT_DESTINATION_ID = 10
  };
  SynFlatBuffers::Type message_type() const {
    return static_cast<SynFlatBuffers::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Agent::State *message_as_Agent_State() const {
    return message_type() == SynFlatBuffers::Type_Agent_State ? static_cast<const SynFlatBuffers::Agent::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Description *message_as_Agent_Description() const {
    return message_type() == SynFlatBuffers::Type_Agent_Description ? static_cast<const SynFlatBuffers::Agent::Description *>(message()) : nullptr;
  }
  const SynFlatBuffers::SPAT::State *message_as_SPAT_State() const {
    return message_type() == SynFlatBuffers::Type_SPAT_State ? static_cast<const SynFlatBuffers::SPAT::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::MAP::State *message_as_MAP_State() const {
    return message_type() == SynFlatBuffers::Type_MAP_State ? static_cast<const SynFlatBuffers::MAP::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Terrain::State *message_as_Terrain_State() const {
    return message_type() == SynFlatBuffers::Type_Terrain_State ? static_cast<const SynFlatBuffers::Terrain::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Approach::State *message_as_Approach_State() const {
    return message_type() == SynFlatBuffers::Type_Approach_State ? static_cast<const SynFlatBuffers::Approach::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Simulation::State *message_as_Simulation_State() const {
    return message_type() == SynFlatBuffers::Type_Simulation_State ? static_cast<const SynFlatBuffers::Simulation::State *>(message()) : nullptr;
  }
  uint32_t source_id() const {
    return GetField<uint32_t>(VT_SOURCE_ID, 0);
  }
  uint32_t destination_id() const {
    return GetField<uint32_t>(VT_DESTINATION_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           VerifyField<uint32_t>(verifier, VT_SOURCE_ID) &&
           VerifyField<uint32_t>(verifier, VT_DESTINATION_ID) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::State *Message::message_as<SynFlatBuffers::Agent::State>() const {
  return message_as_Agent_State();
}

template<> inline const SynFlatBuffers::Agent::Description *Message::message_as<SynFlatBuffers::Agent::Description>() const {
  return message_as_Agent_Description();
}

template<> inline const SynFlatBuffers::SPAT::State *Message::message_as<SynFlatBuffers::SPAT::State>() const {
  return message_as_SPAT_State();
}

template<> inline const SynFlatBuffers::MAP::State *Message::message_as<SynFlatBuffers::MAP::State>() const {
  return message_as_MAP_State();
}

template<> inline const SynFlatBuffers::Terrain::State *Message::message_as<SynFlatBuffers::Terrain::State>() const {
  return message_as_Terrain_State();
}

template<> inline const SynFlatBuffers::Approach::State *Message::message_as<SynFlatBuffers::Approach::State>() const {
  return message_as_Approach_State();
}

template<> inline const SynFlatBuffers::Simulation::State *Message::message_as<SynFlatBuffers::Simulation::State>() const {
  return message_as_Simulation_State();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Type message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  void add_source_id(uint32_t source_id) {
    fbb_.AddElement<uint32_t>(Message::VT_SOURCE_ID, source_id, 0);
  }
  void add_destination_id(uint32_t destination_id) {
    fbb_.AddElement<uint32_t>(Message::VT_DESTINATION_ID, destination_id, 0);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Type message_type = SynFlatBuffers::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    uint32_t source_id = 0,
    uint32_t destination_id = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_destination_id(destination_id);
  builder_.add_source_id(source_id);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

namespace SPAT {

}  // namespace SPAT

namespace Approach {

}  // namespace Approach

namespace MAP {

}  // namespace MAP

namespace Agent {
namespace WheeledVehicle {

}  // namespace WheeledVehicle

namespace TrackedVehicle {

}  // namespace TrackedVehicle

namespace Copter {

}  // namespace Copter

namespace Environment {

}  // namespace Environment

}  // namespace Agent

namespace Terrain {
namespace SCM {

}  // namespace SCM

}  // namespace Terrain

namespace Simulation {

}  // namespace Simulation

namespace Agent {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_WheeledVehicle_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::WheeledVehicle::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_WheeledVehicle_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::WheeledVehicle::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_TrackedVehicle_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::TrackedVehicle::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_TrackedVehicle_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::TrackedVehicle::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Environment_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Environment::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Environment_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Environment::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Copter_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Copter::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Copter_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Copter::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Agent

namespace Terrain {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_SCM_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Terrain::SCM::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Terrain

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Agent_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Agent_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SPAT_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::SPAT::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MAP_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::MAP::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Terrain_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Terrain::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Approach_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Approach::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Simulation_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Simulation::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const SynFlatBuffers::Buffer *GetBuffer(const void *buf) {
  return flatbuffers::GetRoot<SynFlatBuffers::Buffer>(buf);
}

inline const SynFlatBuffers::Buffer *GetSizePrefixedBuffer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SynFlatBuffers::Buffer>(buf);
}

inline bool VerifyBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline bool VerifySizePrefixedBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline void FinishBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SynFlatBuffers

#endif  // FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
