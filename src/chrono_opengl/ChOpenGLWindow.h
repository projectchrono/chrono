// =============================================================================
// PROJECT CHRONO - http://projectchrono.org
//
// Copyright (c) 2014 projectchrono.org
// All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file at the top level of the distribution and at
// http://projectchrono.org/license-chrono.txt.
//
// =============================================================================
// Authors: Hammad Mazhar, Radu Serban
// =============================================================================
// OpenGL window singleton, this class manages the opengl context and window
// =============================================================================

#ifndef CHOPENGLWINDOW_H
#define CHOPENGLWINDOW_H

#include "chrono_opengl/core/ChApiOpenGL.h"
#include "chrono_opengl/ChOpenGLViewer.h"

namespace chrono {

/// Namespace with classes for the Chrono::OpenGL module.
namespace opengl {

/// @addtogroup opengl_module
/// @{

/// Interface of an object which can receive events.
class CH_OPENGL_API ChOpenGLEventCB {
  public:
    virtual ~ChOpenGLEventCB() {}

    /// GLFW callback to handle keyboard events.
    /// Return 'true' if the event is completely done and no further processing is to occur.
    virtual bool CallbackKeyboard(GLFWwindow* window, int key, int scancode, int action, int mode) = 0;

    /// GLFW callback to handle mouse button events.
    /// Return 'true' if the event is completely done and no further processing is to occur.
    virtual bool CallbackMouseButton(GLFWwindow* window, int button, int action, int mods) = 0;

    /// GLFW callback to handle events generated by changes in mouse position.
    /// Return 'true' if the event is completely done and no further processing is to occur.
    virtual bool CallbackMousePos(GLFWwindow* window, double x, double y) = 0;
};

/// Manager for the OpenGL context and window.
class CH_OPENGL_API ChOpenGLWindow {
  public:
    /// Get the unique instance for the OpenGL window.
    static ChOpenGLWindow& getInstance() {
        static ChOpenGLWindow instance;
        return instance;
    }

    /// Initialize the window and set up the OpenGL viewer class.
    void Initialize(int size_x,        ///< Width of window in pixels
                    int size_y,        ///< Height of window in pixels
                    const char* title  ///< Window title string
    );

    /// Attach a Chrono system to the run-time visualization system.
    void AttachSystem(ChSystem* system);

    /// Attach a custom event receiver to the OpenGL window.
    void SetUserEventReceiver(ChOpenGLEventCB* receiver) { user_receivers.push_back(receiver); }

    /// This starts the drawing loop and takes control away from the main program.
    /// This function is the easiest way to start rendering.
    void StartDrawLoop(double time_step  ///< integration step size
    );

    /// Perform a dynamics step, the user needs to use this so that pausing the simulation works correctly.
    bool DoStepDynamics(double time_step  ///< integration step size
    );

    /// Enable/disable HUD display (default: true).
    void EnableHUD(bool state) { render_hud = state; }

    /// Render the ChSystem and the HUD.
    void Render();

    /// Check if the GLFW context is still valid and the window has not been closed.
    bool Active();

    /// Check if the simulation is running or paused.
    bool Running();

    /// Pause simulation.
    void Pause();

    /// Set the camera position, look at and up vectors.
    void SetCamera(ChVector<> pos,                ///< The position of the camera
                   ChVector<> look,               ///< The point that the camera is looking at
                   ChVector<> up,                 ///< The up vector associated with the camera
                   float scale = 0.5f,            ///< zoom level
                   float near_clip_dist = 0.1f,   ///< near clipping distance
                   float far_clip_dist = 1000.0f  ///< far clipping distance
    );

    void SetRenderMode(RenderMode mode) { viewer->render_mode = mode; }

    void SetParticleRenderMode(float radius, RenderMode mode);

    /// Provides the version of the OpenGL context along with driver information.
    static void GLFWGetVersion(GLFWwindow* main_window);

    /// Callback wrapper for steps of the render loop. Works with Emscripten.
    static void WrapRenderStep(void* stepFunction);

    /// Pointer to the opengl viewer that handles rendering, text and user interaction
    ChOpenGLViewer* viewer;

  private:
    ChOpenGLWindow();
    ~ChOpenGLWindow() {}

    ChOpenGLWindow(ChOpenGLWindow const&);  // Don't Implement.
    void operator=(ChOpenGLWindow const&);  // Don't implement

    // GLFW error callback, returns error string.
    static void CallbackError(int error, const char* description);

    // GLFW close callback, called when window is closed.
    static void CallbackClose(GLFWwindow* window);

    // GLFW reshape callback, handles window resizing events.
    static void CallbackReshape(GLFWwindow* window, int w, int h);

    // GLFW keyboard callback, handles keyboard events.
    static void CallbackKeyboard(GLFWwindow* window, int key, int scancode, int action, int mode);

    // GLFW mouse button callback, handles mouse button events.
    static void CallbackMouseButton(GLFWwindow* window, int button, int action, int mods);

    // GLFW mouse position callback, handles events generated by changes in mouse position.
    static void CallbackMousePos(GLFWwindow* window, double x, double y);

    // Pointer to the opengl context
    GLFWwindow* window;
    int poll_frame;
    bool render_hud;
    std::vector<ChOpenGLEventCB*> user_receivers;
};

/// @} opengl_module

}  // namespace opengl
}  // namespace chrono

#endif
