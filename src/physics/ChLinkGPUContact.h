#ifndef CHLINKGPUCONTACT_H
#define CHLINKGPUCONTACT_H

///////////////////////////////////////////////////
//
//   ChLinkGPUcontact.h
//
//   Classes for enforcing constraints (contacts)
//   created by collision detection and managed by GPU
//   parallel solver
//
//   HEADER file for CHRONO,
//	 Multibody dynamics engine
//
// ------------------------------------------------
// 	 Copyright:Alessandro Tasora / DeltaKnowledge
//             www.deltaknowledge.com
// ------------------------------------------------
///////////////////////////////////////////////////



#include "physics/ChLinkContact.h"
#include "lcp/ChLcpConstraintTwoGPUcontN.h"

namespace chrono
{

// Unique link identifier, for detecting type faster than with rtti.
#define LNK_GPUCONTACT	39

///
/// Class representing an unilateral contact constraint, only in case
/// that a GPU parallel solver is used (otherwise you should use 
/// ChLinkFastContact !)
/// Since such objects are automatically generated by the
/// collision detection engine (this type of constraint is 
/// automatically removed from the ChSystem list of links at each
/// step, because their creation/deletion is automated by the
/// collision engine. So, you most often do not need to create any
/// ChLinkGPUcontact)
///

class ChLinkGPUcontact : public ChLinkContact {

	CH_RTTI(ChLinkGPUcontact,ChLinkContact);

protected:
				//
	  			// DATA
				//
	
							// The three scalar constraints, to be feed into the GPU
							// system solver. They do _not_ contain any jacobians data because
							// jacobian will be computed on the GPU only!
	ChLcpConstraintTwoGPUcontN Nx;
	ChLcpConstraintTwoGPUcontT Tu;
	ChLcpConstraintTwoGPUcontT Tv; 

public:
				//
	  			// CONSTRUCTORS
				//

	ChLinkGPUcontact ();

	ChLinkGPUcontact (ChCollisionPair* mpair, 
							ChBody* mbody1, 
							ChBody* mbody2);

	virtual ~ChLinkGPUcontact ();
	virtual void Copy(ChLinkGPUcontact* source);
	virtual ChLink* new_Duplicate ();	// always return base link class pointer


				//
	  			// FUNCTIONS
				//

	virtual int GetType	() {return LNK_GPUCONTACT;}

					/// Initialize again this constraint.
	virtual void Reset(ChCollisionPair* mpair, ChBody* mbody1, ChBody* mbody2);

					/// Get the link coordinate system, expressed relative to Body2 (the 'master'
					/// body). This represents the 'main' reference of the link: reaction forces 
					/// are expressed in this coordinate system.
					/// (It is the coordinate system of the contact plane relative to Body2)
	virtual ChCoordsys<> GetLinkRelativeCoords();

	virtual ChVector<> GetContactP1() {return Nx.GetP1(); };
	virtual ChVector<> GetContactP2() {return Nx.GetP2(); };
	virtual ChVector<float> GetContactNormal()  {return Nx.GetNormal(); };
	virtual double	   GetContactDistance();


				//
				// UPDATING FUNCTIONS
				//

					/// Override _all_ time, jacobian etc. updating.
					/// In detail, it computes jacobians, violations, etc. and stores 
					/// results in inner structures.
	virtual void Update (double mtime) {};


				//
				// LCP INTERFACE
				//

	virtual void InjectConstraints(ChLcpSystemDescriptor& mdescriptor);
	virtual void ConstraintsBiReset();
	virtual void ConstraintsBiLoad_C(double factor=1., double recovery_clamp=0.1, bool do_clamp=false);
	virtual void ConstraintsBiLoad_Ct(double factor=1.);
	//virtual void ConstraintsFbLoadForces(double factor=1.);
	virtual void ConstraintsLoadJacobians();
	virtual void ConstraintsLiLoadSuggestedSpeedSolution();
	virtual void ConstraintsLiLoadSuggestedPositionSolution();
	virtual void ConstraintsLiFetchSuggestedSpeedSolution();
	virtual void ConstraintsLiFetchSuggestedPositionSolution();
	virtual void ConstraintsFetch_react(double factor=1.);


};




//////////////////////////////////////////////////////
//////////////////////////////////////////////////////


} // END_OF_NAMESPACE____

#endif
