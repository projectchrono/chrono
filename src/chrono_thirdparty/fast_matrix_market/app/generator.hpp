// Copyright (C) 2023 Adam Lugowski. All rights reserved.
// Use of this source code is governed by the BSD 2-clause license found in the LICENSE.txt file.
// SPDX-License-Identifier: BSD-2-Clause

#pragma once

#include "../fast_matrix_market.hpp"

namespace fast_matrix_market {
    /**
     * Format (row, col, value) triplets generated by a generator callable like this one:
     * [](auto coo_index, auto& row, auto& col, auto& value) { row = coo_index; col = coo_index; value = 1; }
     */
    template<typename IT, typename VT, typename LF, typename GEN_CALLABLE>
    class coo_independent_generator_formatter {
    public:
        explicit coo_independent_generator_formatter(LF lf, int64_t nnz, GEN_CALLABLE gen_callable) :
            line_formatter(lf), nnz(nnz), gen_callable(gen_callable) {
            if (nnz < 0) {
                throw invalid_argument("nnz cannot be negative.");
            }
        }

        [[nodiscard]] bool has_next() const {
            return next_chunk_offset < nnz;
        }

        class chunk {
        public:
            explicit chunk(LF lf, int64_t chunk_offset, int64_t chunk_nnz, GEN_CALLABLE gen_callable) :
                line_formatter(lf), chunk_offset(chunk_offset), chunk_nnz(chunk_nnz), gen_callable(gen_callable) {
            }

            std::string operator()() {
                std::string chunk;
                chunk.reserve(chunk_nnz*25);
                
                for (int64_t i = 0; i < chunk_nnz; ++i) {
                    IT row, col;
                    VT value;
                    gen_callable(chunk_offset + i, row, col, value);
                    chunk += line_formatter.coord_matrix(row, col, value);
                }

                return chunk;
            }

            LF line_formatter;
            int64_t chunk_offset;
            int64_t chunk_nnz;
            GEN_CALLABLE gen_callable;
        };

        chunk next_chunk(const write_options& options) {
            auto chunk_size = std::min(options.chunk_size_values, (nnz - next_chunk_offset));
            chunk c(line_formatter, next_chunk_offset, chunk_size, gen_callable);
            next_chunk_offset += chunk_size;
            return c;
        }

    protected:
        LF line_formatter;
        int64_t nnz;
        GEN_CALLABLE gen_callable;
        int64_t next_chunk_offset = 0;
    };

    /**
     * Write generated triplets to a Matrix Market file.
     *
     * @tparam IT index type of generated row and column indices
     * @tparam VT value type of generated values
     * @tparam GEN_CALLABLE
     * @param os stream to write to
     * @param header header, use {row, col} syntax for just dimensions
     * @param nnz number of nonzeros in the generated MatrixMarket file
     * @param gen_callable a Callable that accepts the triplet index as an in parameter and row, column, value as out parameter
     * @param options
     */
    template <typename IT, typename VT, typename GEN_CALLABLE>
    void write_matrix_market_generated_triplet(std::ostream &os,
                                               matrix_market_header header,
                                               int64_t nnz,
                                               GEN_CALLABLE gen_callable,
                                               const write_options& options = {}) {
        header.nnz = nnz;

        header.object = matrix;
        if (header.field != pattern && options.fill_header_field_type) {
            header.field = get_field_type((const VT *) nullptr);
        }
        header.format = coordinate;

        write_header(os, header, options);

        line_formatter<IT, VT> lf(header, options);
        auto formatter = coo_independent_generator_formatter<IT, VT, decltype(lf), decltype(gen_callable)>(lf, nnz, gen_callable);
        write_body(os, formatter, options);
    }

}