// =============================================================================
// PROJECT CHRONO - http://projectchrono.org
//
// Copyright (c) 2025 projectchrono.org
// All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file at the top level of the distribution and at
// http://projectchrono.org/license-chrono.txt.
//
// =============================================================================
// Authors: Radu Serban
// =============================================================================
//
// Definition of the ChSoaUniversalBody class.
//
// =============================================================================

#ifndef CH_SOA_UNIVERSAL_BODY_H
#define CH_SOA_UNIVERSAL_BODY_H

#include "chrono/core/ChApiCE.h"

#include "chrono/soa/ChSoaMobilizedBodyT.h"

namespace chrono {
namespace soa {

/// @addtogroup chrono_soa
/// @{

/// Concrete mobilized body with revolute joint.
class ChApi ChSoaUniversalBody : public ChSoaMobilizedBodyT<2> {
  public:
    /// Construct a body mobilized with a revolute joint.
    /// A ChSoaUniversalBody is a mobilizer with two rotational degrees of freedom  (about the x and y-axes). We use a
    /// body-fixed 1-2 Euler rotation sequence for orientation, which has the following effect: starting with frames B
    /// and P aligned (when q0=q1=0), rotate frame B about the Px(=Bx) axis by q0; then, rotate frame B further about
    /// the new By(!=Py) by q1. For generalized speeds u we use the Euler angle derivatives qdot, which are *not* the
    /// same as the angular velocity components because u0 is a rotation rate around Px (which is NOT Bx any more) while
    /// u1 is a rotation rate about By.
    ChSoaUniversalBody(std::shared_ptr<ChSoaMobilizedBody> parent,
                       const ChSoaMassProperties& mprops,
                       const ChFramed& inbFrame,
                       const ChFramed& outbFrame,
                       const std::string& name = "");

    ChSoaUniversalBody(const ChSoaUniversalBody& other);

    /// "Virtual" copy constructor (covariant return type).
    virtual ChSoaUniversalBody* Clone() const override { return new ChSoaUniversalBody(*this); }

    virtual int getNumQ() const override { return 1; }

    // Set the internal coordinates for the ChSoaUniversalBody so they best approximate the specified
    // (relative) orientation, angular velocity, and angular acceleration, respectively.
    // setRelRot() calculates the angles of rotation about the x- and y-axis that best approximate
    // (in the Frobenius norm sense) the given rotation matrix.

    virtual void setRelRot(const ChMatrix33d& relRot) override;
    virtual void setRelLoc(const ChVector3d& relLoc) override {}
    virtual void setRelAngVel(const ChVector3d& relAngVel) override;
    virtual void setRelLinVel(const ChVector3d& relLinVel) override {}
    virtual void setRelAngAcc(const ChVector3d& relAngAcc) override;
    virtual void setRelLinAcc(const ChVector3d& relLinAcc) override {}

    // Mobilizer-specific access to generalized coordinates, velocities, and accelerations.

    void setRelPos(double rotAngleX, double rotAngleY);
    void setRelVel(double rotRateX, double rotRateY);
    void setRelAcc(double rotAccX, double rotAccY);

    virtual double getQ0(int dof) const override;
    virtual double getU0(int dof) const override;

    /// Utility function to calculate the joint rotation matrix corresponding to the specified generalized coordinate.
    static ChMatrix33d calcRelRot(const ChVector2d& q);

  private:
    /// Calculate the across-joint transform X_FM.
    /// X_FM gives the change in position and orientation induced by the joint's generalized coordinates, generated by
    /// the current q values.
    virtual void setJointTransform(const ChVectorDynamic<>& y) override;

    /// Calculate the joint transition matrix H_FM (size 6 x dof).
    /// The generalized speeds for this 2-dof rotational joint are the time derivatives of the body-fixed x-y rotation
    /// sequence defining the orientation. That is, the first speed is just a rotation rate about F frame's x-axis. The
    /// second is a rotation rate about the current y-axis of the M frame, so we have to transform it into F to make
    /// H_FM uniformly expressed in F.
    /// The constant components of H_FM were set at construction.
    virtual void setJointVelMat(const ChVectorDynamic<>& y) override;

    /// Calculate the time derivative of the joint transition matrix H_FM.
    /// The generalized speeds for this 2-dof rotational joint are the time derivatives of the body-fixed x-y rotation
    /// sequence defining the orientation. That is, the first speed is just a rotation rate about F frame's x-axis. The
    /// second is a rotation rate about the current y-axis of the M frame, so we have to transform it into F to make
    /// H_FM uniformly expressed in F.
    /// Since the second row of the Jacobian H_FM is not constant in F, its time derivative is non zero. Here we use the
    /// fact that for a vector r_B_A fixed in a moving frame B but expressed in another frame A, its time derivative in
    /// A is the angular velocity of B in A crossed with the vector, i.e.
    /// <p>
    /// 		d_A/dt r_B_A = w_AB % r_B_A.
    /// </p>
    /// The constant components of H_FM_dot were set at construction.
    virtual void setJointVelMatDot(const ChVectorDynamic<>& y) override;

    /// Allow the body to perform any operations at the beginning of a simulation step.
    virtual void prepSim() override;

    ChVector2d m_q0;
    ChVector2d m_u0;
};

/// @} chrono_soa

}  // namespace soa
}  // namespace chrono

#endif
