// =============================================================================
// PROJECT CHRONO - http://projectchrono.org
//
// Copyright (c) 2024 projectchrono.org
// All rights reserved.
//
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file at the top level of the distribution and at
// http://projectchrono.org/license-chrono.txt.
//
// =============================================================================
// Authors: Radu Serban
// =============================================================================
//
// This file contains the implementation of the ChMobilizedBodyT class. This
// class, derived from ChMobilizedBody, is templatized by the number of degrees
// of freedom (equal to the number of generalized velocities). Concrete classes
// for each type of mobilizer are derived from ChMobilizedBodyT.
//
// =============================================================================

#ifndef CH_MOBILIZED_BODY_T_H
#define CH_MOBILIZED_BODY_T_H

#include <cstring>

#include "chrono/utils/ChUtils.h"
#include "chrono/soa/ChMobilizedBody.h"

namespace chrono {
namespace soa {

/// @addtogroup chrono_soa
/// @{

/// Base class for mobilizers templated by the number of degrees of freedom.
/// The number of DOF is equal to the number of generalized velocities.
/// Concrete classes for each type of mobilizer are derived from ChMobilizedBodyT.
/// Virtual methods that a derived concrete mobilized body must provide are as follows:
/// - setJointPrecalculated: as needed, precalculates any required quantities that do not change at current state
///     (e.g. sines, cosines, quaternion norms, etc.)
/// - setJointTransform: calculates the across-joint transform X_FM, giving the change in position and orientation
///     induced by the joint's generalized coordinates, generated by the current q values. This may depend on quantities
///     already produced by setJointPrecalculated.
/// - setJointVelMat: calculates the joint transition matrix H_FM (size 6 x dof), giving the change of velocity
///     induced by the generalized speeds u for this mobilizer, generated by the current q values. It must be expressed
///		in the mobilizer's inboard "fixed" frame F (attached to the parent).
/// - setJointVelMatDot: calculates the time derivative of H_FM above.
template <int dof>
class ChMobilizedBodyT : public ChMobilizedBody {
  public:
    virtual int getNumU() const { return dof; }

    /// Include the provided force as a mobility force on the specified DOF.
    virtual void addMobilityForce(int which, double force);

    /// Return the current mobility force on the specified DOF.
    double getMobilityForce(int which) const;

    /// Return the constraint mobility force on the specified DIF.
    double getCSMobilityForce(int which) const;

    /// Return the auxiliary Inverse Dynamics mobility force on the specified DOF.
    double getAuxIDMobilityForce(int which) const;

  protected:
    ChMobilizedBodyT(std::shared_ptr<ChMobilizedBody> parent,
                     const ChMassProps& mpropsB,
                     const ChFramed& X_PF,
                     const ChFramed& X_BM,
                     const std::string& name = "");

    /// This recursive function, part of the "Forward Dynamics Analysis" chain, is called in an outward, base-to-tip
    /// traversal of the multibody tree, to calculate the absolute body position and velocity, as well as any position-
    /// and velocity-related quantities required for further dynamic analysis. It assumes that the same function has
    /// already been called for the parent body.
    ///
    /// The concrete mobilizer is first given the opportunity to calculate and cache any precalculated quantities that
    /// could be reused in subsequent traversals for the given state vector.
    ///
    /// The quantities calculated here are as follows:
    /// <pre>
    ///	X_FM		joint transform (mobilizer-specific);
    ///	X_PB		parent-to-child transform;
    ///	X_GB		ground-to-body transform.
    ///	Phi			shift matrix (for velocity and force propagation), using the
    ///				parent-to-child shift vector (OB-OP) expressed in Ground frame;
    ///	inertiaOB_G	inertia matrix about the body frame origin, expressed in Ground;
    ///	CB_G		vector from the body frame origin to the center of mass,
    ///				expressed in Ground frame;
    ///	com_G		location of the center of mass expressed in Ground frame;
    ///	Mk			spatial mass matrix about the body origin;
    ///	H_FM		joint transition matrix (mobilizer-specific);
    ///	V_FM		spatial velocity across the joint;
    ///	H_FM_dot	derivative of H_FM (mobilizer-specific);
    ///	H_PB_G		parent-to child velocity transition matrix (generic);
    ///	H_PB_G_dot	derivative of H_PB_G (generic);
    ///	V_GB		spatial body velocity with respect to Ground;
    ///	gyrForce	gyroscopic spatial force;
    ///	corAcc		Coriolis acceleration, the remainder term in the spatial
    ///				acceleration that depends only on velocities, but involving
    ///				time-derivatives of the Phi and H matrices:
    ///					a = PhiDot * V_GP + HDot * u;
    /// </pre>
    ///
    /// The last operation that this function performs is to call this same function for all the children of this body
    /// to ensure the base-to-tip traversal.
    virtual void orProcPosAndVelFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) override;

    /// This recursive function, called in an outward, base-to-tip traversal of the multibody tree, calculates the
    /// absolute position and all position-dependent kinematic quantities. It assumes that the same function has already
    /// been called for the parent body.
    ///
    /// The concrete mobilizer is first given the opportunity to calculate and cache any precalculated quantities that
    /// could be reused in subsequent traversals for the given state vector.
    /// The quantities calculated here are as follows:
    /// <pre>
    ///	X_FM	joint transform;
    ///	X_PB	parent-to-child transform;
    ///	X_GB	ground-to-body transform.
    ///	Phi		shift matrix (for velocity and force propagation), using the
    ///			parent-to-child shift vector (OB-OP) expressed in Ground frame;
    ///	H_FM	joint transition matrix (mobilizer-specific);
    ///	H_PB_G	parent-to child velocity transition matrix (generic);
    /// </pre>
    ///
    /// The last operation that this function performs is to call this same function for all the children of this body
    /// to ensure the base-to-tip traversal.
    virtual void orProcPosFD(const ChVectorDynamic<>& y) override;

    /// This recursive function, called in an outward, base-to-tip traversal of the multibody tree, calculates the
    /// absolute body velocity. It assumes that a tree traversal to calculate position-level quantities has been
    /// performed and that this same function has already been called for the parent body.
    ///
    /// The quantities calculated here are as follows:
    /// <pre>
    ///	V_FM	spatial velocity across the joint;
    ///	V_GB	spatial body velocity with respect to ground.
    /// </pre>
    ///
    /// The last operation that this function performs is to call this same function for all the children of this body
    /// to ensure the base-to-tip traversal.
    virtual void orProcVelFD(const ChVectorDynamic<>& yd) override;

    /// This recursive function, part of the "Forward Dynamics Analysis" chain, is called in an inward, tip-to-base
    /// traversal of the multibody tree, to calculate the body articulated inertia and the generalized force due to
    /// external forces. It is called only if the multibody system has no active constraints and, as such, all CS forces
    /// are set to zero.
    ///
    /// This function must only be called *after*:
    /// <pre>
    ///	(a)	a call to the base-to-tip traversal orProcPosAndVelFD() so that the body
    ///		position and velocity are available;
    ///	(b)	any external (body and/or mobility) forces have been accounted for.
    /// </pre>
    ///
    /// The first operation that this function performs is to call this same function for all children of the current
    /// body to ensure the tip-to-base traversal.
    virtual void irProcInertiasAndForcesFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) override;

    /// This recursive function, part of the "Forward Dynamics Analysis" chain, is called in an inward, tip-to-base
    /// traversal of the multibody tree, to calculate the body articulated inertia. It is called only if the multibody
    /// system has active constraints.
    ///
    /// This function must only be called *after*:
    /// <pre>
    ///	(a) a call to the base-to-tip traversal orProcPosAndVelFD() so that the body
    ///		position and velocity are available.
    /// </pre>
    ///
    /// The first operation that this function performs is to call this same function for all children of the current
    /// body to ensure the tip-to-base traversal.
    virtual void irProcInertiasFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) override;

    /// This recursive function, part of the "Forward Dynamics Analysis" chain, is called in an inward, tip-to-base
    /// traversal of the multibody tree, to calculate the generalized body force due to external and possibly constraint
    /// forces. It is called only if the multibody system has active constraints, once for evaluating the open-loop
    /// dynamics (in which case all CS forces are set to zero) and a second time for the closed-loop dynamics (in which
    /// case the CS forces are non-zero).
    ///
    /// This function must only be called *after*:
    /// <pre>
    ///	(a) a call to the base-to-tip traversal orProcPosAndVelFD() so that the body
    ///		position and velocity are available;
    ///	(b)	a call to the tip-to-base traversal irProcInertiasFD() so that the body
    ///		articulated inertia is available;
    ///	(c)	any external (body and/or mobility) forces have been accounted for.
    ///	(d) if applicable, the Lagrange multipliers have been calculated and the
    ///		resulting constraint forces applied.
    /// </pre>
    ///
    /// The first operation that this function performs is to call this same function for all children of the current
    /// body to ensure the tip-to-base traversal.
    virtual void irProcForcesFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) override;

    /// This recursive function, part of the "Forward Dynamics Analysis" chain, is called in an outward, base-to-tip
    /// traversal of the multibody tree, to calculate the absolute body acceleration and set the derivative of the state
    /// vector.
    ///
    /// This function must only be called *after*:
    /// <pre>
    ///	(a) a call to the base-to-tip traversal for setting the body positions and
    ///		velocities;
    ///	(b) a call to (one or two) tip-to-base traversals for setting the body
    ///		articulated inertias and process applied forces.
    ///	(c) any external and/or constraint forces have been accounted for.
    /// </pre>
    ///
    /// Note that this function operates with the current values for 'm_nu'. These may account for only the external
    /// forces or they may account for both external and constraint forces, depending on whether it is called while
    /// evaluating the open-loop or closed-loop dynamics.
    ///
    /// The last operation that this function performs is to call this same function for all the children of this body
    /// to ensure the base-to-tip traversal.
    virtual void orProcAccFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd, ChVectorDynamic<>& ydd) override;

    /// This recursive function, part of the "Forward Dynamics Analysis" chain, is called in an inward, tip-to-base
    /// traversal of the multibody tree, to calculate a column of the constraint Jacobian. Inertial effects are *not*
    /// included in this calculation. This function is called only if the multibody system has active constraints.
    ///
    /// This function loads the generalized forces 'eps' into the provided array at the location appropriate for this
    /// body (when the constraint generalized forces are calculated with a set of Lagrange multipliers equal to a column
    /// of the identity matrix, these forces represent the corresponding column of the transposed constraint Jacobian).
    ///
    /// The first operation that this function performs is to call this same function for all children of the current
    /// body to ensure the tip-to-base traversal.
    virtual void irProcConstraintJac(double* vec) override;

    /// Implementation of the first pass in the "Forward Dynamics Analysis" chain to calculate ud = M^-1 * f.
    /// Together with orProcMiF_passTwo, these two functions calculate ud in two O(n) passes.
    /// Here, 'f' is implicitly specified through the current values of the (body and/or mobility) external and
    /// constraint forces for each body in the system. Inertial effects (i.e. centrifugal forces and Coriolis
    /// accelerations) are *not* included in these calculations. It is assumed that the articulated inertia has already
    /// been calculated.
    /// The function irProcMiF_passOne is called in an inward, tip-to-base traversal of the multibody tree, to reduce
    /// all (body and/or mobility) constraint force into generalized forces 'eps'.
    /// Note that external and constraint forces are included with opposite signs. This is due to the fact that each
    /// constraint calculates forces that really correspond to -(Gt * lambda).
    virtual void irProcMiF_passOne() override;

    /// Implementation of the second pass in the "Forward Dynamics Analysis" chain to calculate ud = M^-1 * f.
    /// Together with irProcMiF_passOne, these two functions calculate ud in two O(n) passes.
    /// Here, 'f' is implicitly specified through the current values of the (body and/or mobility) external and
    /// constraint forces for each body in the system. Inertial effects (i.e. centrifugal forces and Coriolis
    /// accelerations) are *not* included in these calculations. It is assumed that the articulated inertia has already
    /// been calculated.
    /// The function orProcMiF_passTwo is called in an outward, base-to-tip traversal of the multibody tree, to
    /// calculate the generalized accelerations (i.e. the derivative of the generalized velocity) based on the set of
    /// forces previously reduced to the joint space during the first traversal.
    /// Note that external and constraint forces are included with opposite signs. This is due to the fact that each
    /// constraint calculates forces that really correspond to -(Gt * lambda).
    virtual void orProcMiF_passTwo(double* ud) override;

    /// This recursive function, part of the "Inverse Dynamics Analysis" chain, is called in an outward, base-to-tip
    /// traversal of the multibody tree, to calculate the absolute body position, velocity, and acceleration. It assumes
    /// that the same function has already been called for the parent body.
    ///
    /// The concrete mobilizer is first given the opportunity to calculate and cache any precalculated quantities that
    /// could be reused in subsequent traversals for the given state vector.
    ///
    /// The quantities calculated here are as follows:
    /// <pre>
    ///	X_FM		joint transform (mobilizer-specific);
    ///	X_PB		parent-to-child transform;
    ///	X_GB		ground-to-body transform.
    ///	Phi			shift matrix (for velocity and force propagation), using the
    ///				parent-to-child shift vector (OB-OP) expressed in Ground frame;
    ///	inertiaOB_G	inertia matrix about the body frame origin, expressed in Ground;
    ///	CB_G		vector from the body frame origin to the center of mass,
    ///				expressed in Ground frame;
    ///	com_G		location of the center of mass expressed in Ground frame;
    ///	Mk			spatial mass matrix about the body origin;
    ///	H_FM		joint transition matrix (mobilizer-specific);
    ///	V_FM		spatial velocity across the joint;
    ///	H_FM_dot	derivative of H_FM (mobilizer-specific);
    ///	H_PB_G		parent-to child velocity transition matrix (generic);
    ///	H_PB_G_dot	derivative of H_PB_G (generic);
    ///	V_GB		spatial body velocity with respect to Ground;
    ///	gyrForce	gyroscopic spatial force;
    ///	corAcc		Coriolis acceleration, the remainder term in the spatial
    ///				acceleration that depends only on velocities, but involving
    ///				time-derivatives of the Phi and H matrices:
    ///					a = PhiDot * V_GP + HDot * u;
    ///	A_GB		the spatial body acceleration with respect to Ground.
    /// </pre>
    ///
    /// The last operation that this function performs is to call this same function for all the children of this body
    /// to ensure the base-to-tip traversal.
    virtual void orProcPosVelAccID(const ChVectorDynamic<>& y,
                                   const ChVectorDynamic<>& yd,
                                   const ChVectorDynamic<>& ydd) override;

    /// This recursive function, part of the "Inverse Dynamics Analysis" chain, is called in an inward, tip-to-base
    /// traversal of the multibody tree, to calculate the body and mobility forces at the given body configuration (i.e.
    /// the current body position, velocity, and acceleration).
    ///
    /// This function must be called only *after*:
    /// <pre>
    ///	(a)	the base-to-tip traversal orProcPosVelAccID() so that the body
    ///		positions, velocities, and acceleration are available
    ///	(b)	any desired external forces have been accounted for.
    /// </pre>
    ///
    /// This means that, on entry, 'm_bodyForce' contains any external body forces applied directly to this body and
    /// 'm_mobilityForce' contains any external hinge forces applied directly to the mobilizer inboard joint.
    ///
    /// The quantity calculated here is 'm_mobilityForceID',	the auxiliary mobility (hinge) forces that should be
    /// applied to this mobilized body, in *addition* to any other external forces (body and/or hinge), in order to
    /// achieve the desired body acceleration.
    ///
    /// The first operation that this function performs is to call this same function for all children of the current
    /// body to ensure the tip-to-base traversal.
    virtual void irProcForcesID(const ChVectorDynamic<>& y,
                                const ChVectorDynamic<>& yd,
                                const ChVectorDynamic<>& ydd) override;

    /// Include the provided force as a constraint mobility force on the specified DOF.
    virtual void applyCSMobilityForce(int which, double force) override;

    /// Set to zero the constraint body and mobility forces.
    virtual void resetForcesCS() override;

    /// Preclculate any required quantities that do not change at current state.
    /// The default implementation of setJointPrecalculated is no-op. A mobilizer should implement this method only if
    /// it can take advantage of precalculated quantities.
    virtual void setJointPrecalculated(const ChVectorDynamic<>& y) {}

    /// Calculate the across-joint transform X_FM.
    /// X_FM gives the change in position and orientation induced by the joint's generalized coordinates, generated by
    /// the current q values. This may depend on quantities already produced by setJointPrecalculated.
    virtual void setJointTransform(const ChVectorDynamic<>& y) = 0;

    /// Calculate the joint transition matrix H_FM (size 6 x dof).
    /// H_FM gives the change of velocity induced by the generalized speeds u for this mobilizer, generated by the
    /// current q values. It must be expressed in the mobilizer's inboard "fixed" frame F (attached to the parent).
    /// The default implementation of setJointVelMat is a no-op. A concrete mobilizer for which H_FM is constant should
    /// set it at construction and thus need not implement this function.
    virtual void setJointVelMat(const ChVectorDynamic<>& y) {}

    /// Calculate the time derivative of the joint transition matrix H_FM.
    /// The default implementation of setJointVelMatDot is a no-op. A concrete mobilizer for which H_FM is constant
    /// should set H_FM_dot = 0 at construction and thus need not implement this function.
    virtual void setJointVelMatDot(const ChVectorDynamic<>& y) {}

    ChVelMat<dof> m_H_FM;
    ChVelMat<dof> m_H;

    ChVelMat<dof> m_H_FM_dot;
    ChVelMat<dof> m_H_dot;

    ChMatrixNM<double, dof, dof> m_Di;
    ChVelMat<dof> m_G;
    ChVectorN<double, dof> m_nu;

    ChVectorN<double, dof> m_mobilityForce;
    ChVectorN<double, dof> m_mobilityForceCS;
    ChVectorN<double, dof> m_mobilityForceID;

  private:
    /// Calculate the velocity transform H = H_PB_G.
    /// H_PB_G represents the transition matrix giving the velocity change from parent to child, expressed in the ground
    /// frame. This function is called in a based-to-tip[ traversal and therefore the parent transform X_GP as well as
    /// the transition matrix H_FM are available.
    /// 
    /// This function calculates the following quantities:
    /// <pre>
    ///	r_MB_F		vector from OM, the origin of the M frame to OB, the origin of
    ///				the body frame, expressed in the fixed frame F;
    ///	H_MB		velocity transition matrix, incorporating the shift OM-OB;
    ///	H			parent-to child velocity transition matrix:
    ///					H == H_PB_G = R_GF * (m_H_FM - H_MB),
    ///				where R_GF = R_GP * R_PF is used here to express the cross-joint
    ///				velocity V_FB (== V_PB) in the ground frame, to get V_PB_G;
    /// </pre>
    void calcParentToChildVelMat();

    /// Calculate the velocity transform H = H_PB_G and its time derivative.
    /// H_PB_G represents the transition matrix giving the velocity change from parent to child, expressed in the ground
    /// frame. This function is called in a based-to-tip[ traversal and therefore the parent transform X_GP as well as
    /// the transition matrix H_FM are available.
    /// This function calculates the following quantities:
    /// <pre>
    ///	r_MB_F		vector from OM, the origin of the M frame to OB, the origin of
    ///				the body frame, expressed in the fixed frame F;
    ///	H_MB		velocity transition matrix, incorporating the shift OM-OB;
    ///	H			parent-to child velocity transition matrix:
    ///					H == H_PB_G = R_GF * (m_H_FM - H_MB),
    ///				where R_GF = R_GP * R_PF is used here to express the cross-joint
    ///				velocity V_FB (== V_PB) in the ground frame, to get V_PB_G;
    ///	H_dot		derivative of the transition matrix H. Note that the derivative
    ///				of R_GF is crossMat(w_GF)*R_GF, where w_GF is the angular
    ///				velocity of F in G (angular velocities of F and M are the same).
    /// </pre>
    void calcParentToChildVelMatDot();

    /// This function calculates the articulated inertia for this body. It is called
    /// from either irProcInertiasAndForcesFD() or irProcInertiasFD() during an
    /// inward, tip-to-base traversal of the multibody tree.
    ///
    /// The quantities calculated here are as follows:
    /// <pre>
    ///	P			articulated body inertia, based on quantities already available
    ///				from the children:
    ///					P = Mk + sum_children { ~Phi * Pplus * Phi };
    ///	D			generalized mass matrix: D = ~H * P * H;
    ///	G			acceleration propagator: G = P * H * D^(-1);
    ///	Pplus		local contribution to the parent's articulated inertia:
    ///					P+ = P - P * H * D^(-1) * ~H * P;
    /// </pre>
    void calcArticulatedInertia();

    /// This function calculates the generalized force acting on the inboard joint of this body due to external and
    /// possibly constraint forces. It is called from either irProcInertiasAndForcesFD() or irProcForcesFD() during an
    /// inward, tip-to-base traversal of the multibody tree. It assumes that the articulated inertia has already been
    /// calculated.
    ///
    /// The quantities calculated here are as follows:
    /// <pre>
    ///	cntrfForce	centrifugal forces, the sum of Coriolis and gyroscopic forces;
    ///	Z			generalized body forces, based on quantities already available
    ///				from the children:
    ///					z = cntrfForce - bodyForce + sum_children { ~Phi * zplus }
    ///	eps			generalized forces, including mobility forces and (transformed)
    ///				body forces: eps = T - ~H * z;
    ///	nu			generalized accelerations: nu = D^(-1) * eps;
    ///	Zplus		local contribution to the parent's generalized body force:
    ///					Zplus = Z + G * eps.
    /// </pre>
    ///
    /// Note that external and constraint forces are included with opposite signs. This is due to the fact that each
    /// constraint calculates forces that really correspond to -(Gt * lambda).
    void calcGeneralizedForce();

    /// Get a constant reference to the states of this mobilizer in the provided assembly-wide vector.
    const ChVectorN<double, dof> myU(const ChVectorDynamic<>& yd) const { return yd.segment(m_uIdx, dof); }
    const ChVectorN<double, dof> myU(double* yd) const {
        return Eigen::Map<ChVectorN<double, dof>>(&yd[m_uIdx], dof, 1);
    }

    ////const ChVectorN<double, dof>& myU(const ChVectorDynamic<>& yd) const { return yd.segment(m_uIdx, dof); }
    ////const ChVectorN<double, dof>& myU(double* yd) const {
    ////    return Eigen::Map<ChVectorN<double, dof>>(&yd[m_uIdx], dof, 1);
    ////}

    ////const Eigen::Ref<ChVectorN<double, dof>>& myU(const ChVectorDynamic<>& yd) const { return yd.segment(m_uIdx, dof); }
    ////const Eigen::Ref<ChVectorN<double, dof>>& myU(double* yd) const {
    ////    return Eigen::Map<ChVectorN<double, dof>>(&yd[m_uIdx], dof, 1);
    ////}

    /// Set (copy) the states of this mobilizer into the provided assembly-wide state vector.
    void setMyU(ChVectorDynamic<>& yd, const ChVectorN<double, dof>& u);
    void setMyU(double* yd, const ChVectorN<double, dof>& u);
};

// -----------------------------------------------------------------------------

template <int dof>
inline ChMobilizedBodyT<dof>::ChMobilizedBodyT(std::shared_ptr<ChMobilizedBody> parent,
                                               const ChMassProps& mpropsB,
                                               const ChFramed& X_PF,
                                               const ChFramed& X_BM,
                                               const std::string& name)
    : ChMobilizedBody(parent, mpropsB, X_PF, X_BM, name) {}

template <int dof>
inline void ChMobilizedBodyT<dof>::setMyU(ChVectorDynamic<>& y, const ChVectorN<double, dof>& u) {
    y.segment(m_uIdx, dof) = u;
}

template <int dof>
inline void ChMobilizedBodyT<dof>::setMyU(double* y, const ChVectorN<double, dof>& u) {
    std::memcpy(&y[m_uIdx], u.data(), dof);
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::orProcPosFD(const ChVectorDynamic<>& y) {
    setJointPrecalculated(y);

    // Calculate the body position
    setJointTransform(y);

    m_X_PB = m_X_PF * m_X_FM * m_X_BM.GetInverse();

    if (getParent()->isGround())
        m_absPos = m_X_PB;
    else
        m_absPos = getParent()->getAbsPos() * m_X_PB;

    // Calculate position-dependent quantities
    if (getParent()->isGround())
        m_Phi = ChShiftMat(m_X_PB.GetPos());
    else
        m_Phi = ChShiftMat(getParent()->getAbsPos().GetRotMat() * m_X_PB.GetPos());

    setJointVelMat(y);
    calcParentToChildVelMat();

    // Initialize the constraint forces to zero
    m_bodyForceCS.setZero();
    m_mobilityForceCS.setZero();

    // Request the children to perform same operation
    ChMobilizedBody::orProcPosFD(y);
}

template <int dof>
inline void ChMobilizedBodyT<dof>::orProcVelFD(const ChVectorDynamic<>& yd) {
    m_V_FM = m_H_FM * myU(yd);

    if (getParent()->isGround())
        m_absVel = m_H * myU(yd);
    else
        m_absVel = m_Phi * getParent()->getAbsVel() + m_H * myU(yd);

    // Request the children to perform same operation
    ChMobilizedBody::orProcVelFD(yd);
}

template <int dof>
inline void ChMobilizedBodyT<dof>::orProcPosAndVelFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) {
    setJointPrecalculated(y);

    // Calculate the body position
    setJointTransform(y);

    m_X_PB = m_X_PF * m_X_FM * m_X_BM.GetInverse();

    if (getParent()->isGround())
        m_absPos = m_X_PB;
    else
        m_absPos = getParent()->getAbsPos() * m_X_PB;

    // Calculate position-dependent quantities
    if (getParent()->isGround())
        m_Phi = ChShiftMat(m_X_PB.GetPos());
    else
        m_Phi = ChShiftMat(getParent()->getAbsPos().GetRotMat() * m_X_PB.GetPos());

    const ChMatrix33d& R_GB = m_absPos.GetRotMat();
    const ChVector3d& t_GB = m_absPos.GetPos();

    m_inertiaOB_G = R_GB.transpose() * m_mpropsB.inertia() * R_GB;
    m_CB_G = R_GB * m_mpropsB.com();
    m_com_G = t_GB + m_CB_G;

    auto offDiag = m_mpropsB.mass() * ChStarMatrix33d(m_CB_G);
    m_Mk = ChSpatialMat(m_inertiaOB_G, offDiag, -offDiag, m_mpropsB.mass() * ChMatrix33d(1));

    // Calculate the body spatial velocity and velocity-dependent quantities.
    // Note that if this body is locked, we treat is similarly to an mbWeldBody
    if (m_locked) {
        if (getParent()->isGround()) {
            m_absVel.setZero();
            m_gyrForce.setZero();
            m_corAcc.setZero();
            m_corAccT.setZero();
        } else {
            m_absVel = m_Phi * getParent()->getAbsVel();

            const ChVector3d& w_GB = m_absVel.ang();
            const ChVector3d& v_GB = m_absVel.lin();

            m_gyrForce = ChSpatialVec(w_GB % (m_inertiaOB_G * w_GB), m_mpropsB.mass() * (w_GB % (w_GB % m_CB_G)));

            const ChVector3d& w_GP = getParent()->getAbsVel().ang();
            const ChVector3d& v_GP = getParent()->getAbsVel().lin();

            m_corAcc = ChSpatialVec(ChVector3d(0.0), w_GP % (v_GB - v_GP));
            m_corAccT = m_Phi * getParent()->m_corAccT + m_corAcc;
        }
    } else {
        setJointVelMat(y);

        m_V_FM = m_H_FM * myU(yd);

        setJointVelMatDot(y);

        calcParentToChildVelMatDot();

        if (getParent()->isGround())
            m_absVel = m_H * myU(yd);
        else
            m_absVel = m_Phi * getParent()->getAbsVel() + m_H * myU(yd);

        const ChVector3d& w_GB = m_absVel.ang();
        const ChVector3d& v_GB = m_absVel.lin();

        m_gyrForce = ChSpatialVec(w_GB % (m_inertiaOB_G * w_GB), m_mpropsB.mass() * (w_GB % (w_GB % m_CB_G)));

        if (getParent()->isGround()) {
            m_corAcc = m_H_dot * myU(yd);
            m_corAccT = m_corAcc;
        } else {
            const ChVector3d& w_GP = getParent()->getAbsVel().ang();
            const ChVector3d& v_GP = getParent()->getAbsVel().lin();

            m_corAcc = ChSpatialVec(ChVector3d(0.0f), w_GP % (v_GB - v_GP)) + m_H_dot * myU(yd);
            m_corAccT = m_Phi * getParent()->m_corAccT + m_corAcc;
        }
    }

    // Update the contact model at new position
    //// TODO -- contact
    ////if (m_contact)
    ////    m_contact->update();

    // Initialize the body, mobility, and constraint forces to zero
    m_bodyForce.setZero();
    m_mobilityForce.setZero();

    m_bodyForceCS.setZero();
    m_mobilityForceCS.setZero();

    // Request the children to perform same operation
    ChMobilizedBody::orProcPosAndVelFD(y, yd);
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::calcParentToChildVelMat() {
    const auto& r_MB = (m_X_BM.GetInverse()).GetPos();
    const auto& R_FM = m_X_FM.GetRotMat();

    const ChVector3d r_MB_F = R_FM * r_MB;

    ChVelMat<dof> H_MB;

    H_MB.ang().setZero();
    H_MB.lin() = ChStarMatrix33d(r_MB_F) * m_H_FM.ang();

    if (getParent()->isGround())
        m_H = m_X_PF.GetRotMat() * (m_H_FM - H_MB);
    else {
        const ChMatrix33d R_GF = getParent()->getAbsPos().GetRotMat() * m_X_PF.GetRotMat();
        m_H = R_GF * (m_H_FM - H_MB);
    }
}

template <int dof>
inline void ChMobilizedBodyT<dof>::calcParentToChildVelMatDot() {
    const auto& r_MB = (m_X_BM.GetInverse()).GetPos();
    const auto& R_FM = m_X_FM.GetRotMat();

    const ChVector3d r_MB_F = R_FM * r_MB;

    const auto& w_FM = m_V_FM.ang();

    ChVelMat<dof> H_MB;
    ChVelMat<dof> H_MB_dot;

    H_MB.ang().setZero();
    H_MB.lin() = ChStarMatrix33d(r_MB_F) * m_H_FM.ang();

    H_MB_dot.ang().setZero();
    H_MB_dot.lin() = ChStarMatrix33d(r_MB_F) * m_H_FM_dot.ang() + ChStarMatrix33d(w_FM % r_MB_F) * m_H_FM.ang();

    if (getParent()->isGround()) {
        const ChMatrix33d& R_PF = m_X_PF.GetRotMat();
        m_H = R_PF * (m_H_FM - H_MB);
        m_H_dot = R_PF * (m_H_FM_dot - H_MB_dot);
    } else {
        const auto& w_GF = getParent()->getAbsVel().ang();
        const ChMatrix33d R_GF = getParent()->getAbsPos().GetRotMat() * m_X_PF.GetRotMat();
        m_H = R_GF * (m_H_FM - H_MB);
        m_H_dot = R_GF * (m_H_FM_dot - H_MB_dot) + ChStarMatrix33d(w_GF) * m_H;
    }
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::irProcInertiasAndForcesFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) {
    ChMobilizedBody::irProcInertiasAndForcesFD(y, yd);

    calcArticulatedInertia();
    calcGeneralizedForce();
}

template <int dof>
inline void ChMobilizedBodyT<dof>::irProcInertiasFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) {
    ChMobilizedBody::irProcInertiasFD(y, yd);

    calcArticulatedInertia();
}

template <int dof>
inline void ChMobilizedBodyT<dof>::irProcForcesFD(const ChVectorDynamic<>& y, const ChVectorDynamic<>& yd) {
    ChMobilizedBody::irProcForcesFD(y, yd);

    calcGeneralizedForce();
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::calcArticulatedInertia() {
    ChSpatialMat P = m_Mk;

    for (int i = 0; i < getNumChildren(); i++)
        P += ChSpatialMat::constructFrom(getChild(i)->m_Pplus, getChild(i)->m_Phi);

    ChVelMat<dof> PH = P * m_H;

    m_Di = ~m_H * PH;
    m_Di.inverse();
    m_G = PH * m_Di;

    if (!getParent()->isGround())
        m_Pplus = P - ChSpatialMat::constructFrom(PH, m_Di);

    m_cntrfForce = P * m_corAcc + m_gyrForce;
}

template <int dof>
inline void ChMobilizedBodyT<dof>::calcGeneralizedForce() {
    ChSpatialVec Z = m_cntrfForce - m_bodyForce + m_bodyForceCS;

    for (int i = 0; i < getNumChildren(); i++)
        Z += ~getChild(i)->m_Phi * getChild(i)->m_Zplus;

    ChVectorN<double, dof> eps = m_mobilityForce - m_mobilityForceCS - ~m_H * Z;

    m_nu = m_Di * eps;

    if (!getParent()->isGround())
        m_Zplus = Z + m_G * eps;
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::orProcAccFD(const ChVectorDynamic<>& y,
                                               const ChVectorDynamic<>& yd,
                                               ChVectorDynamic<>& ydd) {
    if (m_locked) {
        // If this body is locked, set its state derivatives to zero and calculate the body spatial acceleration which,
        // in this case, is just the sum of the parent's shifted acceleration and the Coriolis acceleration (same as for
        // an ChWeldBody)
        for (int i = 0; i < getNumQ(); i++)
            ydd[m_qIdx + i] = 0;
        for (int i = 0; i < getNumU(); i++)
            ydd[m_uIdx + i] = 0;

        m_absAcc = m_corAcc;

        if (!getParent()->isGround())
            m_absAcc += m_Phi * getParent()->getAbsAcc();
    } else {
        // Set the derivatives of the generalized coordinates
        ////setQDot(y, yd);  //// TODO -- needed?

        // Calculate the body acceleration and set the derivatives of generalized velocities
        if (getParent()->isGround()) {
            setMyU(ydd, m_nu);
            m_absAcc = m_H * myU(ydd) + m_corAcc;
        } else {
            ChSpatialVec alphap = m_Phi * getParent()->getAbsAcc();
            setMyU(ydd, m_nu - (~m_G * alphap));
            m_absAcc = alphap + m_H * myU(ydd) + m_corAcc;
        }
    }

    // Request the children to perform same operation.
    ChMobilizedBody::orProcAccFD(y, yd, ydd);
}

template <int dof>
inline void ChMobilizedBodyT<dof>::irProcConstraintJac(double* vec) {
    // Request the children to perform same operation
    ChMobilizedBody::irProcConstraintJac(vec);

    // Calculate the generalized joint force 'eps' due to constraint forces but do not include any inertial components.
    // Note that constraint forces must be included with a sign opposite to what would be used for external forces. This
    // is due to the fact that each constraint calculates forces that really correspond to -(Gt * lambda).
    ChSpatialVec Z = m_bodyForceCS;

    for (int i = 0; i < getNumChildren(); i++)
        Z += ~getChild(i)->m_Phi * getChild(i)->m_Zplus;

    setMyU(vec, -m_mobilityForceCS - ~m_H * Z);

    if (!getParent()->isGround())
        m_Zplus = Z;
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::irProcMiF_passOne() {
    // Request the children to perform same operation
    ChMobilizedBody::irProcMiF_passOne();

    // Calculate the generalized joint force 'eps' and joint acceleration 'm_nu' due to all applied forces (excluding
    // centrifugal forces). Note that constraint forces have opposite sign to the external forces
    ChSpatialVec Z = -m_bodyForce + m_bodyForceCS;

    for (int i = 0; i < getNumChildren(); i++)
        Z += ~getChild(i)->m_Phi * getChild(i)->m_Zplus;

    ChVectorN<double, dof> eps = m_mobilityForce - m_mobilityForceCS - ~m_H * Z;

    m_nu = m_Di * eps;

    if (!getParent()->isGround())
        m_Zplus = Z + m_G * eps;
}

template <int dof>
inline void ChMobilizedBodyT<dof>::orProcMiF_passTwo(double* ud) {
    // Set the derivatives of the generalized velocities due to the applied forces (excluding Coriolis acceleration)
    if (getParent()->isGround()) {
        setMyU(ud, m_nu);
        m_absAcc = m_H * myU(ud);
    } else {
        ChSpatialVec alphap = m_Phi * getParent()->getAbsAcc();
        setMyU(ud, m_nu - (~m_G * alphap));
        m_absAcc = alphap + m_H * myU(ud);
    }

    // Request the children to perform same operation
    ChMobilizedBody::orProcMiF_passTwo(ud);
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::orProcPosVelAccID(const ChVectorDynamic<>& y,
                                                     const ChVectorDynamic<>& yd,
                                                     const ChVectorDynamic<>& ydd) {
    setJointPrecalculated(y);

    // Calculate the body position and position-dependent quantities
    setJointTransform(y);

    m_X_PB = m_X_PF * m_X_FM * m_X_BM.GetInverse();

    if (getParent()->isGround())
        m_absPos = m_X_PB;
    else
        m_absPos = getParent()->getAbsPos() * m_X_PB;

    if (getParent()->isGround())
        m_Phi = ChShiftMat(m_X_PB.GetPos());
    else
        m_Phi = ChShiftMat(getParent()->getAbsPos().GetRotMat() * m_X_PB.GetPos());

    const ChMatrix33d& R_GB = m_absPos.GetRotMat();
    const ChVector3d& t_GB = m_absPos.GetPos();

    m_inertiaOB_G = R_GB.transpose() * R_GB.transpose() * R_GB;
    m_CB_G = R_GB * m_mpropsB.com();
    m_com_G = t_GB + m_CB_G;

    auto offDiag = m_mpropsB.mass() * ChStarMatrix33d(m_CB_G);
    m_Mk = ChSpatialMat(m_inertiaOB_G, offDiag, -offDiag, m_mpropsB.mass() * ChMatrix33d(1));

    // Calculate the body spatial velocity and velocity-dependent quantities
    setJointVelMat(y);

    m_V_FM = m_H_FM * myU(yd);

    setJointVelMatDot(y);

    calcParentToChildVelMatDot();

    if (getParent()->isGround())
        m_absVel = m_H * myU(yd);
    else
        m_absVel = m_Phi * getParent()->getAbsVel() + m_H * myU(yd);

    const auto& w_GB = m_absVel.ang();
    const auto& v_GB = m_absVel.lin();

    m_gyrForce = ChSpatialVec(w_GB % (m_inertiaOB_G * w_GB), m_mpropsB.mass() * (w_GB % (w_GB % m_CB_G)));

    if (getParent()->isGround()) {
        m_corAcc = m_H_dot * myU(yd);
        m_corAccT = m_corAcc;
    } else {
        const auto& w_GP = getParent()->getAbsVel().ang();
        const auto& v_GP = getParent()->getAbsVel().lin();

        m_corAcc = ChSpatialVec(ChVector3d(0), w_GP % (v_GB - v_GP)) + m_H_dot * myU(yd);
        m_corAccT = m_Phi * getParent()->m_corAccT + m_corAcc;
    }

    // Update the contact model at new position.
    //// TODO -- contact
    ////if (m_contact)
    ////    m_contact->update();

    // Calculate the body spatial acceleration
    if (getParent()->isGround())
        m_absAcc = m_H * myU(ydd) + m_corAcc;
    else
        m_absAcc = m_Phi * getParent()->getAbsAcc() + m_H * myU(ydd) + m_corAcc;

    // Initialize the body, mobility, constraint, and auxiliary ID forces to zero
    m_bodyForce.setZero();
    m_mobilityForce.setZero();

    m_bodyForceCS.setZero();
    m_mobilityForceCS.setZero();

    m_mobilityForceID.setZero();

    // Request the children to perform same operation
    ChMobilizedBody::orProcPosVelAccID(y, yd, ydd);
}

template <int dof>
inline void ChMobilizedBodyT<dof>::irProcForcesID(const ChVectorDynamic<>& y,
                                                  const ChVectorDynamic<>& yd,
                                                  const ChVectorDynamic<>& ydd) {
    // Request the children to perform same operation
    ChMobilizedBody::irProcForcesID(y, yd, ydd);

    // Overwrite the body spatial force with the sum of the inertial force (due to the desired body acceleration) and
    // the gyroscopic force (due to angular velocity) minus the external body forces
    m_bodyForce = m_Mk * m_absAcc + m_gyrForce - m_bodyForce;

    // Include the body forces on the children bodies, shifted to the frame of this body
    for (int i = 0; i < getNumChildren(); i++)
        m_bodyForce += ~getChild(i)->m_Phi * getChild(i)->m_bodyForce;

    // Project the body force into the joint space and subtract any external mobility forces, to obtain the remaining
    // hinge forces needed to produce the desired acceleration
    m_mobilityForceID = ~m_H * m_bodyForce - m_mobilityForce;
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::addMobilityForce(int which, double force) {
    ChAssertAlways(which >= 0 && which < dof);

    m_mobilityForce[which] += force;
}

template <int dof>
inline double ChMobilizedBodyT<dof>::getMobilityForce(int which) const {
    assert(which >= 0 && which < dof);

    return m_mobilityForce[which];
}

template <int dof>
inline void ChMobilizedBodyT<dof>::applyCSMobilityForce(int which, double force) {
    assert(which >= 0 && which < dof);

    m_mobilityForceCS[which] += force;
}

template <int dof>
inline double ChMobilizedBodyT<dof>::getCSMobilityForce(int which) const {
    assert(which >= 0 && which < dof);

    return m_mobilityForceCS[which];
}

// -----------------------------------------------------------------------------

template <int dof>
inline void ChMobilizedBodyT<dof>::resetForcesCS() {
    m_bodyForceCS.setZero();
    m_mobilityForceCS.setZero();
}

// -----------------------------------------------------------------------------

template <int dof>
inline double ChMobilizedBodyT<dof>::getAuxIDMobilityForce(int which) const {
    assert(which >= 0 && which < dof);

    return m_mobilityForceID[which];
}

/// @} chrono_soa

}  // namespace soa
}  // namespace chrono

#endif
